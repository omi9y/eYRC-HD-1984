
Final.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800200  00002756  000027ea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002756  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000064  0080021e  0080021e  00002808  2**0
                  ALLOC
  3 .stab         000023f4  00000000  00000000  00002808  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000076a  00000000  00000000  00004bfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000a0  00000000  00000000  00005368  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000024c6  00000000  00000000  00005408  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000003be  00000000  00000000  000078ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000bf3  00000000  00000000  00007c8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000818  00000000  00000000  00008880  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000073c  00000000  00000000  00009098  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001988  00000000  00000000  000097d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000030  00000000  00000000  0000b15c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__vector_1>
       8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      14:	0c 94 71 05 	jmp	0xae2	; 0xae2 <__vector_5>
      18:	0c 94 4c 05 	jmp	0xa98	; 0xa98 <__vector_6>
      1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e6 e5       	ldi	r30, 0x56	; 86
      fc:	f7 e2       	ldi	r31, 0x27	; 39
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ae 31       	cpi	r26, 0x1E	; 30
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	12 e0       	ldi	r17, 0x02	; 2
     110:	ae e1       	ldi	r26, 0x1E	; 30
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a2 38       	cpi	r26, 0x82	; 130
     11a:	b1 07       	cpc	r27, r17
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 61 10 	call	0x20c2	; 0x20c2 <main>
     122:	0c 94 a9 13 	jmp	0x2752	; 0x2752 <_exit>

00000126 <__bad_interrupt>:
     126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <left_position_encoder_interrupt_init>:
 * Logic: Set INT4 to trigger with falling edge
 * Example Call: left_position_encoder_interrupt_init ();
 */ 
void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
     12a:	f8 94       	cli
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     12c:	ea e6       	ldi	r30, 0x6A	; 106
     12e:	f0 e0       	ldi	r31, 0x00	; 0
     130:	80 81       	ld	r24, Z
     132:	82 60       	ori	r24, 0x02	; 2
     134:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     136:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
     138:	78 94       	sei
}
     13a:	08 95       	ret

0000013c <right_position_encoder_interrupt_init>:
 * Logic: Set INT5 to trigger with falling edge
 * Example Call: right_position_encoder_interrupt_init ();
 */
void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
     13c:	f8 94       	cli
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     13e:	ea e6       	ldi	r30, 0x6A	; 106
     140:	f0 e0       	ldi	r31, 0x00	; 0
     142:	80 81       	ld	r24, Z
     144:	88 60       	ori	r24, 0x08	; 8
     146:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     148:	ed 9a       	sbi	0x1d, 5	; 29
	sei();   // Enables the global interrupt
     14a:	78 94       	sei
}
     14c:	08 95       	ret

0000014e <buzzer_on>:
 * Logic: Setting the pin 3 of port C to high
 * Example Call: buzzer_on();
 */ 
void buzzer_on(){
	
	PORTC = 0x08;
     14e:	88 e0       	ldi	r24, 0x08	; 8
     150:	88 b9       	out	0x08, r24	; 8
}
     152:	08 95       	ret

00000154 <buzzer_off>:
 * Output :  Turns off the buzzer  
 * Logic: Reset the pin 3 of port C to high 
 * Example Call: buzzer_off();
 */ 
void buzzer_off(){
	PORTC = 0x00;
     154:	18 b8       	out	0x08, r1	; 8
}
     156:	08 95       	ret

00000158 <lcd_port_config>:
 * Logic: Function to configure LCD port
 * Example Call: lcd_port_config();
 */ 
void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7; 
     158:	87 b1       	in	r24, 0x07	; 7
     15a:	87 6f       	ori	r24, 0xF7	; 247
     15c:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80;
     15e:	88 b1       	in	r24, 0x08	; 8
     160:	80 78       	andi	r24, 0x80	; 128
     162:	88 b9       	out	0x08, r24	; 8
}
     164:	08 95       	ret

00000166 <adc_pin_config>:
 * Logic: Function to configure the adc pins
 * Example Call: adc_pin_config ();
 */ 
void adc_pin_config (void)
{
	DDRF = 0x00;
     166:	10 ba       	out	0x10, r1	; 16
	PORTF = 0x00;
     168:	11 ba       	out	0x11, r1	; 17
	DDRK = 0x00;
     16a:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00;
     16e:	10 92 08 01 	sts	0x0108, r1
}
     172:	08 95       	ret

00000174 <adc_init>:
 * Logic: Function to initialize the adc
 * Example Call: adc_init();
 */ 
void adc_init()
{
	ADCSRA = 0x00;
     174:	ea e7       	ldi	r30, 0x7A	; 122
     176:	f0 e0       	ldi	r31, 0x00	; 0
     178:	10 82       	st	Z, r1
	ADCSRB = 0x00;		
     17a:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		
     17e:	80 e2       	ldi	r24, 0x20	; 32
     180:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
     184:	80 e8       	ldi	r24, 0x80	; 128
     186:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		
     188:	86 e8       	ldi	r24, 0x86	; 134
     18a:	80 83       	st	Z, r24
}
     18c:	08 95       	ret

0000018e <ADC_Conversion>:
 * Example Call:  ADC_Conversion('2');
 */ 
unsigned char ADC_Conversion(unsigned char Ch)
{
	unsigned char a;
	if(Ch>7)
     18e:	88 30       	cpi	r24, 0x08	; 8
     190:	18 f0       	brcs	.+6      	; 0x198 <ADC_Conversion+0xa>
	{
		ADCSRB = 0x08;
     192:	98 e0       	ldi	r25, 0x08	; 8
     194:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;
     198:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;
     19a:	80 62       	ori	r24, 0x20	; 32
     19c:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		
     1a0:	ea e7       	ldi	r30, 0x7A	; 122
     1a2:	f0 e0       	ldi	r31, 0x00	; 0
     1a4:	80 81       	ld	r24, Z
     1a6:	80 64       	ori	r24, 0x40	; 64
     1a8:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	
     1aa:	80 81       	ld	r24, Z
     1ac:	84 ff       	sbrs	r24, 4
     1ae:	fd cf       	rjmp	.-6      	; 0x1aa <ADC_Conversion+0x1c>
	a=ADCH;
     1b0:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; 
     1b4:	ea e7       	ldi	r30, 0x7A	; 122
     1b6:	f0 e0       	ldi	r31, 0x00	; 0
     1b8:	90 81       	ld	r25, Z
     1ba:	90 61       	ori	r25, 0x10	; 16
     1bc:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     1be:	10 92 7b 00 	sts	0x007B, r1
	return a;
     1c2:	08 95       	ret

000001c4 <color_sensor_pin_config>:
 * Logic: Send the required signals to the color sensor pin
 * Example Call: color_sensor_pin_config();
 */
void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
     1c4:	8a b1       	in	r24, 0x0a	; 10
     1c6:	8e 6f       	ori	r24, 0xFE	; 254
     1c8:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
     1ca:	58 9a       	sbi	0x0b, 0	; 11
}
     1cc:	08 95       	ret

000001ce <port_init_color>:
 * Logic: Send the required signals to the color sensor pin
 * Example Call: port_init_color();
 */
void port_init_color(void)
{
	lcd_port_config();//lcd pin configuration
     1ce:	0e 94 ac 00 	call	0x158	; 0x158 <lcd_port_config>
	color_sensor_pin_config();//color sensor pin configuration
     1d2:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <color_sensor_pin_config>
}
     1d6:	08 95       	ret

000001d8 <color_sensor_pin_interrupt_init>:
 * Logic:  Enables the interrupt
 * Example Call: color_sensor_pin_interrupt_init();
 */
void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     1d8:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
     1da:	e9 e6       	ldi	r30, 0x69	; 105
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	80 81       	ld	r24, Z
     1e0:	82 60       	ori	r24, 0x02	; 2
     1e2:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
     1e4:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
     1e6:	78 94       	sei
}
     1e8:	08 95       	ret

000001ea <__vector_1>:
 * Output :  ISR for color sensor
 * Logic:  ISR for color sensor
 * Example Call: Automatically called
 */
ISR(INT0_vect)
{
     1ea:	1f 92       	push	r1
     1ec:	0f 92       	push	r0
     1ee:	0f b6       	in	r0, 0x3f	; 63
     1f0:	0f 92       	push	r0
     1f2:	11 24       	eor	r1, r1
     1f4:	8f 93       	push	r24
     1f6:	9f 93       	push	r25
     1f8:	af 93       	push	r26
     1fa:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     1fc:	80 91 54 02 	lds	r24, 0x0254
     200:	90 91 55 02 	lds	r25, 0x0255
     204:	a0 91 56 02 	lds	r26, 0x0256
     208:	b0 91 57 02 	lds	r27, 0x0257
     20c:	01 96       	adiw	r24, 0x01	; 1
     20e:	a1 1d       	adc	r26, r1
     210:	b1 1d       	adc	r27, r1
     212:	80 93 54 02 	sts	0x0254, r24
     216:	90 93 55 02 	sts	0x0255, r25
     21a:	a0 93 56 02 	sts	0x0256, r26
     21e:	b0 93 57 02 	sts	0x0257, r27
}
     222:	bf 91       	pop	r27
     224:	af 91       	pop	r26
     226:	9f 91       	pop	r25
     228:	8f 91       	pop	r24
     22a:	0f 90       	pop	r0
     22c:	0f be       	out	0x3f, r0	; 63
     22e:	0f 90       	pop	r0
     230:	1f 90       	pop	r1
     232:	18 95       	reti

00000234 <init_devices_color>:
 * Logic: Enables the interrupt 
 * Example Call: init_devices_color();
 */
void init_devices_color(void)
{
	cli(); //Clears the global interrupt
     234:	f8 94       	cli
	port_init_color();  //Initializes all the ports
     236:	0e 94 e7 00 	call	0x1ce	; 0x1ce <port_init_color>
	color_sensor_pin_interrupt_init();
     23a:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <color_sensor_pin_interrupt_init>
	sei();   // Enables the global interrupt
     23e:	78 94       	sei
}
     240:	08 95       	ret

00000242 <filter_red>:
 * Example Call: filter_red();
 */
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
     242:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
     244:	5f 98       	cbi	0x0b, 7	; 11
}
     246:	08 95       	ret

00000248 <filter_green>:
 * Example Call: filter_green();
 */
void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
     248:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     24a:	5f 9a       	sbi	0x0b, 7	; 11
}
     24c:	08 95       	ret

0000024e <filter_blue>:
 * Example Call: filter_blue();
 */
void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
     24e:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     250:	5f 9a       	sbi	0x0b, 7	; 11
}
     252:	08 95       	ret

00000254 <color_sensor_scaling>:
 * Logic: sets s0  and s1 high  
 * Example Call: color_sensor_scaling();
 */
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	PORTD = PORTD | 0x10; //set S0 high
     254:	5c 9a       	sbi	0x0b, 4	; 11
	PORTD = PORTD | 0x20; //set S1 high
     256:	5d 9a       	sbi	0x0b, 5	; 11
}
     258:	08 95       	ret

0000025a <red_read>:
 * Output : to read the red pulse
 * Logic: counts the reflected pulse with delay of few ms 
 * Example Call: red_read();
 */
volatile unsigned long int red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
     25a:	0f 93       	push	r16
     25c:	1f 93       	push	r17
	//Red
	filter_red(); //select red filter
     25e:	0e 94 21 01 	call	0x242	; 0x242 <filter_red>
	pulse=0; //reset the count to 0
     262:	10 92 54 02 	sts	0x0254, r1
     266:	10 92 55 02 	sts	0x0255, r1
     26a:	10 92 56 02 	sts	0x0256, r1
     26e:	10 92 57 02 	sts	0x0257, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     272:	8f ef       	ldi	r24, 0xFF	; 255
     274:	9f e7       	ldi	r25, 0x7F	; 127
     276:	a4 e0       	ldi	r26, 0x04	; 4
     278:	81 50       	subi	r24, 0x01	; 1
     27a:	90 40       	sbci	r25, 0x00	; 0
     27c:	a0 40       	sbci	r26, 0x00	; 0
     27e:	e1 f7       	brne	.-8      	; 0x278 <red_read+0x1e>
     280:	00 c0       	rjmp	.+0      	; 0x282 <red_read+0x28>
     282:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
     284:	80 91 54 02 	lds	r24, 0x0254
     288:	90 91 55 02 	lds	r25, 0x0255
     28c:	a0 91 56 02 	lds	r26, 0x0256
     290:	b0 91 57 02 	lds	r27, 0x0257
     294:	80 93 6a 02 	sts	0x026A, r24
     298:	90 93 6b 02 	sts	0x026B, r25
     29c:	a0 93 6c 02 	sts	0x026C, r26
     2a0:	b0 93 6d 02 	sts	0x026D, r27
	return red;
     2a4:	00 91 6a 02 	lds	r16, 0x026A
     2a8:	10 91 6b 02 	lds	r17, 0x026B
     2ac:	20 91 6c 02 	lds	r18, 0x026C
     2b0:	30 91 6d 02 	lds	r19, 0x026D
}
     2b4:	60 2f       	mov	r22, r16
     2b6:	71 2f       	mov	r23, r17
     2b8:	82 2f       	mov	r24, r18
     2ba:	93 2f       	mov	r25, r19
     2bc:	1f 91       	pop	r17
     2be:	0f 91       	pop	r16
     2c0:	08 95       	ret

000002c2 <green_read>:
 * Output : to read the green pulse
 * Logic: counts the reflected pulse with delay of few ms 
 * Example Call: green_read();
 */
volatile unsigned long int green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
     2c2:	0f 93       	push	r16
     2c4:	1f 93       	push	r17
	//Green
	filter_green(); //select green filter
     2c6:	0e 94 24 01 	call	0x248	; 0x248 <filter_green>
	pulse=0; //reset the count to 0
     2ca:	10 92 54 02 	sts	0x0254, r1
     2ce:	10 92 55 02 	sts	0x0255, r1
     2d2:	10 92 56 02 	sts	0x0256, r1
     2d6:	10 92 57 02 	sts	0x0257, r1
     2da:	8f ef       	ldi	r24, 0xFF	; 255
     2dc:	9f e7       	ldi	r25, 0x7F	; 127
     2de:	a4 e0       	ldi	r26, 0x04	; 4
     2e0:	81 50       	subi	r24, 0x01	; 1
     2e2:	90 40       	sbci	r25, 0x00	; 0
     2e4:	a0 40       	sbci	r26, 0x00	; 0
     2e6:	e1 f7       	brne	.-8      	; 0x2e0 <green_read+0x1e>
     2e8:	00 c0       	rjmp	.+0      	; 0x2ea <green_read+0x28>
     2ea:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
     2ec:	80 91 54 02 	lds	r24, 0x0254
     2f0:	90 91 55 02 	lds	r25, 0x0255
     2f4:	a0 91 56 02 	lds	r26, 0x0256
     2f8:	b0 91 57 02 	lds	r27, 0x0257
     2fc:	80 93 62 02 	sts	0x0262, r24
     300:	90 93 63 02 	sts	0x0263, r25
     304:	a0 93 64 02 	sts	0x0264, r26
     308:	b0 93 65 02 	sts	0x0265, r27
	return green;
     30c:	00 91 62 02 	lds	r16, 0x0262
     310:	10 91 63 02 	lds	r17, 0x0263
     314:	20 91 64 02 	lds	r18, 0x0264
     318:	30 91 65 02 	lds	r19, 0x0265
}
     31c:	60 2f       	mov	r22, r16
     31e:	71 2f       	mov	r23, r17
     320:	82 2f       	mov	r24, r18
     322:	93 2f       	mov	r25, r19
     324:	1f 91       	pop	r17
     326:	0f 91       	pop	r16
     328:	08 95       	ret

0000032a <blue_read>:
 * Output : to read the blue pulse
 * Logic: counts the reflected pulse with delay of few ms 
 * Example Call: blue_read();
 */
volatile unsigned long int blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
     32a:	0f 93       	push	r16
     32c:	1f 93       	push	r17
	//Blue
	filter_blue(); //select blue filter
     32e:	0e 94 27 01 	call	0x24e	; 0x24e <filter_blue>
	pulse=0; //reset the count to 0
     332:	10 92 54 02 	sts	0x0254, r1
     336:	10 92 55 02 	sts	0x0255, r1
     33a:	10 92 56 02 	sts	0x0256, r1
     33e:	10 92 57 02 	sts	0x0257, r1
     342:	8f ef       	ldi	r24, 0xFF	; 255
     344:	9f e7       	ldi	r25, 0x7F	; 127
     346:	a4 e0       	ldi	r26, 0x04	; 4
     348:	81 50       	subi	r24, 0x01	; 1
     34a:	90 40       	sbci	r25, 0x00	; 0
     34c:	a0 40       	sbci	r26, 0x00	; 0
     34e:	e1 f7       	brne	.-8      	; 0x348 <blue_read+0x1e>
     350:	00 c0       	rjmp	.+0      	; 0x352 <blue_read+0x28>
     352:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
     354:	80 91 54 02 	lds	r24, 0x0254
     358:	90 91 55 02 	lds	r25, 0x0255
     35c:	a0 91 56 02 	lds	r26, 0x0256
     360:	b0 91 57 02 	lds	r27, 0x0257
     364:	80 93 58 02 	sts	0x0258, r24
     368:	90 93 59 02 	sts	0x0259, r25
     36c:	a0 93 5a 02 	sts	0x025A, r26
     370:	b0 93 5b 02 	sts	0x025B, r27
	return blue;
     374:	00 91 58 02 	lds	r16, 0x0258
     378:	10 91 59 02 	lds	r17, 0x0259
     37c:	20 91 5a 02 	lds	r18, 0x025A
     380:	30 91 5b 02 	lds	r19, 0x025B
}
     384:	60 2f       	mov	r22, r16
     386:	71 2f       	mov	r23, r17
     388:	82 2f       	mov	r24, r18
     38a:	93 2f       	mov	r25, r19
     38c:	1f 91       	pop	r17
     38e:	0f 91       	pop	r16
     390:	08 95       	ret

00000392 <detect_color>:
 * Function Name:detect_color()
 * Input :  None 
 * Output : to detect the color
 * Example Call: detect_color();
 */
int detect_color() {
     392:	ef 92       	push	r14
     394:	ff 92       	push	r15
     396:	0f 93       	push	r16
     398:	1f 93       	push	r17
     39a:	cf 93       	push	r28
     39c:	df 93       	push	r29
	int detected = 0;
	RED = red_read();
     39e:	0e 94 2d 01 	call	0x25a	; 0x25a <red_read>
     3a2:	dc 01       	movw	r26, r24
     3a4:	cb 01       	movw	r24, r22
     3a6:	80 93 7e 02 	sts	0x027E, r24
     3aa:	90 93 7f 02 	sts	0x027F, r25
     3ae:	a0 93 80 02 	sts	0x0280, r26
     3b2:	b0 93 81 02 	sts	0x0281, r27
	BLUE = blue_read();
     3b6:	0e 94 95 01 	call	0x32a	; 0x32a <blue_read>
     3ba:	dc 01       	movw	r26, r24
     3bc:	cb 01       	movw	r24, r22
     3be:	80 93 66 02 	sts	0x0266, r24
     3c2:	90 93 67 02 	sts	0x0267, r25
     3c6:	a0 93 68 02 	sts	0x0268, r26
     3ca:	b0 93 69 02 	sts	0x0269, r27
	GREEN = green_read();
     3ce:	0e 94 61 01 	call	0x2c2	; 0x2c2 <green_read>
     3d2:	dc 01       	movw	r26, r24
     3d4:	cb 01       	movw	r24, r22
     3d6:	80 93 6e 02 	sts	0x026E, r24
     3da:	90 93 6f 02 	sts	0x026F, r25
     3de:	a0 93 70 02 	sts	0x0270, r26
     3e2:	b0 93 71 02 	sts	0x0271, r27
	lcd_cursor(2,1);
     3e6:	0f 2e       	mov	r0, r31
     3e8:	ff ec       	ldi	r31, 0xCF	; 207
     3ea:	ef 2e       	mov	r14, r31
     3ec:	f7 e0       	ldi	r31, 0x07	; 7
     3ee:	ff 2e       	mov	r15, r31
     3f0:	f0 2d       	mov	r31, r0
     3f2:	82 e0       	ldi	r24, 0x02	; 2
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	61 e0       	ldi	r22, 0x01	; 1
     3f8:	70 e0       	ldi	r23, 0x00	; 0
     3fa:	f7 01       	movw	r30, r14
     3fc:	19 95       	eicall
	lcd_print(2,1,RED,3);
     3fe:	ce e3       	ldi	r28, 0x3E	; 62
     400:	d8 e0       	ldi	r29, 0x08	; 8
     402:	20 91 7e 02 	lds	r18, 0x027E
     406:	30 91 7f 02 	lds	r19, 0x027F
     40a:	40 91 80 02 	lds	r20, 0x0280
     40e:	50 91 81 02 	lds	r21, 0x0281
     412:	82 e0       	ldi	r24, 0x02	; 2
     414:	90 e0       	ldi	r25, 0x00	; 0
     416:	61 e0       	ldi	r22, 0x01	; 1
     418:	70 e0       	ldi	r23, 0x00	; 0
     41a:	03 e0       	ldi	r16, 0x03	; 3
     41c:	10 e0       	ldi	r17, 0x00	; 0
     41e:	fe 01       	movw	r30, r28
     420:	19 95       	eicall
	lcd_print(2,6,BLUE,3);
     422:	20 91 66 02 	lds	r18, 0x0266
     426:	30 91 67 02 	lds	r19, 0x0267
     42a:	40 91 68 02 	lds	r20, 0x0268
     42e:	50 91 69 02 	lds	r21, 0x0269
     432:	82 e0       	ldi	r24, 0x02	; 2
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	66 e0       	ldi	r22, 0x06	; 6
     438:	70 e0       	ldi	r23, 0x00	; 0
     43a:	fe 01       	movw	r30, r28
     43c:	19 95       	eicall
	lcd_print(2,10,GREEN,3);
     43e:	20 91 6e 02 	lds	r18, 0x026E
     442:	30 91 6f 02 	lds	r19, 0x026F
     446:	40 91 70 02 	lds	r20, 0x0270
     44a:	50 91 71 02 	lds	r21, 0x0271
     44e:	82 e0       	ldi	r24, 0x02	; 2
     450:	90 e0       	ldi	r25, 0x00	; 0
     452:	6a e0       	ldi	r22, 0x0A	; 10
     454:	70 e0       	ldi	r23, 0x00	; 0
     456:	fe 01       	movw	r30, r28
     458:	19 95       	eicall
	lcd_cursor(2,13);
     45a:	82 e0       	ldi	r24, 0x02	; 2
     45c:	90 e0       	ldi	r25, 0x00	; 0
     45e:	6d e0       	ldi	r22, 0x0D	; 13
     460:	70 e0       	ldi	r23, 0x00	; 0
     462:	f7 01       	movw	r30, r14
     464:	19 95       	eicall
	if (RED > BLUE) {
     466:	40 91 7e 02 	lds	r20, 0x027E
     46a:	50 91 7f 02 	lds	r21, 0x027F
     46e:	60 91 80 02 	lds	r22, 0x0280
     472:	70 91 81 02 	lds	r23, 0x0281
     476:	80 91 66 02 	lds	r24, 0x0266
     47a:	90 91 67 02 	lds	r25, 0x0267
     47e:	a0 91 68 02 	lds	r26, 0x0268
     482:	b0 91 69 02 	lds	r27, 0x0269
     486:	84 17       	cp	r24, r20
     488:	95 07       	cpc	r25, r21
     48a:	a6 07       	cpc	r26, r22
     48c:	b7 07       	cpc	r27, r23
     48e:	c0 f4       	brcc	.+48     	; 0x4c0 <detect_color+0x12e>
		if (RED > GREEN) {
     490:	40 91 7e 02 	lds	r20, 0x027E
     494:	50 91 7f 02 	lds	r21, 0x027F
     498:	60 91 80 02 	lds	r22, 0x0280
     49c:	70 91 81 02 	lds	r23, 0x0281
     4a0:	80 91 6e 02 	lds	r24, 0x026E
     4a4:	90 91 6f 02 	lds	r25, 0x026F
     4a8:	a0 91 70 02 	lds	r26, 0x0270
     4ac:	b0 91 71 02 	lds	r27, 0x0271
     4b0:	84 17       	cp	r24, r20
     4b2:	95 07       	cpc	r25, r21
     4b4:	a6 07       	cpc	r26, r22
     4b6:	b7 07       	cpc	r27, r23
     4b8:	d8 f4       	brcc	.+54     	; 0x4f0 <detect_color+0x15e>
			detected = 1;
     4ba:	81 e0       	ldi	r24, 0x01	; 1
     4bc:	90 e0       	ldi	r25, 0x00	; 0
     4be:	1d c0       	rjmp	.+58     	; 0x4fa <detect_color+0x168>
		}
		else {
			detected = 2;
		}
	} else {
		if (BLUE > GREEN) {
     4c0:	40 91 66 02 	lds	r20, 0x0266
     4c4:	50 91 67 02 	lds	r21, 0x0267
     4c8:	60 91 68 02 	lds	r22, 0x0268
     4cc:	70 91 69 02 	lds	r23, 0x0269
     4d0:	80 91 6e 02 	lds	r24, 0x026E
     4d4:	90 91 6f 02 	lds	r25, 0x026F
     4d8:	a0 91 70 02 	lds	r26, 0x0270
     4dc:	b0 91 71 02 	lds	r27, 0x0271
     4e0:	84 17       	cp	r24, r20
     4e2:	95 07       	cpc	r25, r21
     4e4:	a6 07       	cpc	r26, r22
     4e6:	b7 07       	cpc	r27, r23
     4e8:	30 f4       	brcc	.+12     	; 0x4f6 <detect_color+0x164>
			detected = 3;
     4ea:	83 e0       	ldi	r24, 0x03	; 3
     4ec:	90 e0       	ldi	r25, 0x00	; 0
     4ee:	05 c0       	rjmp	.+10     	; 0x4fa <detect_color+0x168>
	if (RED > BLUE) {
		if (RED > GREEN) {
			detected = 1;
		}
		else {
			detected = 2;
     4f0:	82 e0       	ldi	r24, 0x02	; 2
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	02 c0       	rjmp	.+4      	; 0x4fa <detect_color+0x168>
	} else {
		if (BLUE > GREEN) {
			detected = 3;
		}
		else {
			detected = 2;
     4f6:	82 e0       	ldi	r24, 0x02	; 2
     4f8:	90 e0       	ldi	r25, 0x00	; 0
		}
	}
	return detected;
	
}
     4fa:	df 91       	pop	r29
     4fc:	cf 91       	pop	r28
     4fe:	1f 91       	pop	r17
     500:	0f 91       	pop	r16
     502:	ff 90       	pop	r15
     504:	ef 90       	pop	r14
     506:	08 95       	ret

00000508 <print_color>:
 * Input :  color
 * Output : prints the color on lcd
 * Logic: simply passes the value to be printed on lcd by calling lcd_string function from lcd header file 
 * Example Call: print_color(int color);
 */
void print_color(int color) {
     508:	cf 93       	push	r28
     50a:	df 93       	push	r29
     50c:	ec 01       	movw	r28, r24
	lcd_cursor(2,1);
     50e:	82 e0       	ldi	r24, 0x02	; 2
     510:	90 e0       	ldi	r25, 0x00	; 0
     512:	61 e0       	ldi	r22, 0x01	; 1
     514:	70 e0       	ldi	r23, 0x00	; 0
     516:	0e 94 cf 07 	call	0xf9e	; 0xf9e <lcd_cursor>
	if (color == 1)
     51a:	c1 30       	cpi	r28, 0x01	; 1
     51c:	d1 05       	cpc	r29, r1
     51e:	29 f4       	brne	.+10     	; 0x52a <print_color+0x22>
	lcd_string("Red");
     520:	80 e0       	ldi	r24, 0x00	; 0
     522:	92 e0       	ldi	r25, 0x02	; 2
     524:	0e 94 2b 08 	call	0x1056	; 0x1056 <lcd_string>
     528:	0c c0       	rjmp	.+24     	; 0x542 <print_color+0x3a>
	else if (color == 2)
     52a:	c2 30       	cpi	r28, 0x02	; 2
     52c:	d1 05       	cpc	r29, r1
     52e:	29 f4       	brne	.+10     	; 0x53a <print_color+0x32>
	lcd_string("Green");
     530:	84 e0       	ldi	r24, 0x04	; 4
     532:	92 e0       	ldi	r25, 0x02	; 2
     534:	0e 94 2b 08 	call	0x1056	; 0x1056 <lcd_string>
     538:	04 c0       	rjmp	.+8      	; 0x542 <print_color+0x3a>
	else
	lcd_string("Blue");
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	92 e0       	ldi	r25, 0x02	; 2
     53e:	0e 94 2b 08 	call	0x1056	; 0x1056 <lcd_string>
     542:	df 91       	pop	r29
     544:	cf 91       	pop	r28
     546:	08 95       	ret

00000548 <motion_pin_config>:
 * Logic: set the pins
 * Example Call: motion_pin_config ();
 */ 
void motion_pin_config (void) 
{
 DDRA = DDRA | 0x0F;
     548:	81 b1       	in	r24, 0x01	; 1
     54a:	8f 60       	ori	r24, 0x0F	; 15
     54c:	81 b9       	out	0x01, r24	; 1
 PORTA = PORTA & 0xF0;
     54e:	82 b1       	in	r24, 0x02	; 2
     550:	80 7f       	andi	r24, 0xF0	; 240
     552:	82 b9       	out	0x02, r24	; 2
 DDRL = DDRL | 0x18;  
     554:	ea e0       	ldi	r30, 0x0A	; 10
     556:	f1 e0       	ldi	r31, 0x01	; 1
     558:	80 81       	ld	r24, Z
     55a:	88 61       	ori	r24, 0x18	; 24
     55c:	80 83       	st	Z, r24
 PORTL = PORTL | 0x18;
     55e:	eb e0       	ldi	r30, 0x0B	; 11
     560:	f1 e0       	ldi	r31, 0x01	; 1
     562:	80 81       	ld	r24, Z
     564:	88 61       	ori	r24, 0x18	; 24
     566:	80 83       	st	Z, r24
}
     568:	08 95       	ret

0000056a <timer5_init>:
 * Logic: Set the timer5 in 10bit PWM mode 
 * Example Call: timer5_init();
 */
void timer5_init()
{
	TCCR5B = 0x00;	
     56a:	e1 e2       	ldi	r30, 0x21	; 33
     56c:	f1 e0       	ldi	r31, 0x01	; 1
     56e:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	
     570:	8f ef       	ldi	r24, 0xFF	; 255
     572:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	
     576:	91 e0       	ldi	r25, 0x01	; 1
     578:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	
     57c:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	
     580:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	
     584:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	
     588:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	
     58c:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	
     590:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	
     594:	89 ea       	ldi	r24, 0xA9	; 169
     596:	80 93 20 01 	sts	0x0120, r24
	TCCR5B = 0x0B;	
     59a:	8b e0       	ldi	r24, 0x0B	; 11
     59c:	80 83       	st	Z, r24
}
     59e:	08 95       	ret

000005a0 <motion_set>:
void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 			
 PortARestore = PORTA; 			
     5a0:	92 b1       	in	r25, 0x02	; 2
 PortARestore &= 0xF0; 			
     5a2:	90 7f       	andi	r25, 0xF0	; 240
 */ 
void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 			
     5a4:	8f 70       	andi	r24, 0x0F	; 15
 PortARestore = PORTA; 			
 PortARestore &= 0xF0; 			
 PortARestore |= Direction; 	
     5a6:	98 2b       	or	r25, r24
 PORTA = PortARestore; 			
     5a8:	92 b9       	out	0x02, r25	; 2
}
     5aa:	08 95       	ret

000005ac <forward>:
 * Logic: Send the signals through motion_set function 
 * Example Call: forward ();
 */ 
void forward (void)
{
  motion_set(0x06);
     5ac:	86 e0       	ldi	r24, 0x06	; 6
     5ae:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <motion_set>
}
     5b2:	08 95       	ret

000005b4 <back>:
 * Logic: Send the signals through motion_set function 
 * Example Call: back ();
 */ 
void back (void)
{
  motion_set(0x09);
     5b4:	89 e0       	ldi	r24, 0x09	; 9
     5b6:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <motion_set>
}
     5ba:	08 95       	ret

000005bc <left>:
 * Logic: Send the signals through motion_set function 
 * Example Call: left ();
 */ 
void left (void)
{
  motion_set(0x05);
     5bc:	85 e0       	ldi	r24, 0x05	; 5
     5be:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <motion_set>
}
     5c2:	08 95       	ret

000005c4 <right>:
 * Logic: Send the signals through motion_set function 
 * Example Call: right ();
 */ 
void right (void) 
{
  motion_set(0x0A);
     5c4:	8a e0       	ldi	r24, 0x0A	; 10
     5c6:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <motion_set>
}
     5ca:	08 95       	ret

000005cc <soft_left>:
 * Logic: Send the signals through motion_set function 
 * Example Call: soft_left ();
 */
void soft_left (void) 
{
 motion_set(0x04);
     5cc:	84 e0       	ldi	r24, 0x04	; 4
     5ce:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <motion_set>
}
     5d2:	08 95       	ret

000005d4 <stop>:
 * Logic: Send the signals through motion_set function 
 * Example Call: stop ();
 */
void stop()
{
motion_set(0x00);
     5d4:	80 e0       	ldi	r24, 0x00	; 0
     5d6:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <motion_set>
}
     5da:	08 95       	ret

000005dc <soft_right>:
 * Logic: Send the signals through motion_set function 
 * Example Call: soft_right ();
 */
void soft_right (void) //Left wheel forward, Right wheel is stationary
{
	motion_set(0x02);
     5dc:	82 e0       	ldi	r24, 0x02	; 2
     5de:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <motion_set>
}
     5e2:	08 95       	ret

000005e4 <soft_left_2>:
 * Logic: Send the signals through motion_set function 
 * Example Call: soft_left_2 ();
 */
void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
	motion_set(0x01);
     5e4:	81 e0       	ldi	r24, 0x01	; 1
     5e6:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <motion_set>
}
     5ea:	08 95       	ret

000005ec <soft_right_2>:
 * Logic: Send the signals through motion_set function 
 * Example Call: soft_right_2 ();
 */
void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
	motion_set(0x08);
     5ec:	88 e0       	ldi	r24, 0x08	; 8
     5ee:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <motion_set>
}
     5f2:	08 95       	ret

000005f4 <velocity>:
 * Logic: Load the input data in OCR5AL & OCR5BL registers
 * Example Call: velocity (177,180);
 */ 
void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     5f4:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
     5f8:	60 93 2a 01 	sts	0x012A, r22
}
     5fc:	08 95       	ret

000005fe <print_sensor>:
* Output : It will print the data on lcd screen
* Logic: It will print the data on lcd screen
* Example Call: print_sensor(1,4,23,3);
*/
void print_sensor(char row, char coloumn,unsigned char channel)
{
     5fe:	cf 93       	push	r28
     600:	df 93       	push	r29
     602:	d8 2f       	mov	r29, r24
     604:	c6 2f       	mov	r28, r22
     606:	84 2f       	mov	r24, r20
	
	int ADC_Value = ADC_Conversion(channel);
     608:	0e 94 c7 00 	call	0x18e	; 0x18e <ADC_Conversion>
     60c:	48 2f       	mov	r20, r24
	lcd_print(row, coloumn, ADC_Value, 3);
     60e:	8d 2f       	mov	r24, r29
     610:	90 e0       	ldi	r25, 0x00	; 0
     612:	6c 2f       	mov	r22, r28
     614:	70 e0       	ldi	r23, 0x00	; 0
     616:	50 e0       	ldi	r21, 0x00	; 0
     618:	23 e0       	ldi	r18, 0x03	; 3
     61a:	30 e0       	ldi	r19, 0x00	; 0
     61c:	0e 94 3e 08 	call	0x107c	; 0x107c <lcd_print>
}
     620:	df 91       	pop	r29
     622:	cf 91       	pop	r28
     624:	08 95       	ret

00000626 <fw_control_motor_speed>:
* Output : none
* Logic: It will control the motor speed
* Example Call: fw_control_motor_speed();
*/
void fw_control_motor_speed()
{
     626:	8f 92       	push	r8
     628:	9f 92       	push	r9
     62a:	af 92       	push	r10
     62c:	bf 92       	push	r11
     62e:	cf 92       	push	r12
     630:	df 92       	push	r13
     632:	ef 92       	push	r14
     634:	ff 92       	push	r15
     636:	cf 93       	push	r28
     638:	df 93       	push	r29
	left_motor_speed = initial_motor_speed + PID_value;
     63a:	60 91 10 02 	lds	r22, 0x0210
     63e:	70 91 11 02 	lds	r23, 0x0211
     642:	88 27       	eor	r24, r24
     644:	77 fd       	sbrc	r23, 7
     646:	80 95       	com	r24
     648:	98 2f       	mov	r25, r24
     64a:	0e 94 82 12 	call	0x2504	; 0x2504 <__floatsisf>
     64e:	6b 01       	movw	r12, r22
     650:	7c 01       	movw	r14, r24
     652:	80 90 3d 02 	lds	r8, 0x023D
     656:	90 90 3e 02 	lds	r9, 0x023E
     65a:	a0 90 3f 02 	lds	r10, 0x023F
     65e:	b0 90 40 02 	lds	r11, 0x0240
     662:	a5 01       	movw	r20, r10
     664:	94 01       	movw	r18, r8
     666:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     66a:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     66e:	dc 01       	movw	r26, r24
     670:	cb 01       	movw	r24, r22
     672:	ec 01       	movw	r28, r24
     674:	90 93 75 02 	sts	0x0275, r25
     678:	80 93 74 02 	sts	0x0274, r24
	right_motor_speed = initial_motor_speed - PID_value + 20;
     67c:	c7 01       	movw	r24, r14
     67e:	b6 01       	movw	r22, r12
     680:	a5 01       	movw	r20, r10
     682:	94 01       	movw	r18, r8
     684:	0e 94 7e 11 	call	0x22fc	; 0x22fc <__subsf3>
     688:	20 e0       	ldi	r18, 0x00	; 0
     68a:	30 e0       	ldi	r19, 0x00	; 0
     68c:	40 ea       	ldi	r20, 0xA0	; 160
     68e:	51 e4       	ldi	r21, 0x41	; 65
     690:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     694:	0e 94 4f 12 	call	0x249e	; 0x249e <__fixsfsi>
     698:	ab 01       	movw	r20, r22
     69a:	bc 01       	movw	r22, r24
     69c:	ca 01       	movw	r24, r20
     69e:	50 93 77 02 	sts	0x0277, r21
     6a2:	40 93 76 02 	sts	0x0276, r20
	if(left_motor_speed<=0)
     6a6:	1c 16       	cp	r1, r28
     6a8:	1d 06       	cpc	r1, r29
     6aa:	24 f0       	brlt	.+8      	; 0x6b4 <fw_control_motor_speed+0x8e>
	{
		left_motor_speed=0;
     6ac:	10 92 75 02 	sts	0x0275, r1
     6b0:	10 92 74 02 	sts	0x0274, r1
	}
	if (right_motor_speed<=0)
     6b4:	18 16       	cp	r1, r24
     6b6:	19 06       	cpc	r1, r25
     6b8:	24 f0       	brlt	.+8      	; 0x6c2 <fw_control_motor_speed+0x9c>
	{
		right_motor_speed=0;
     6ba:	10 92 77 02 	sts	0x0277, r1
     6be:	10 92 76 02 	sts	0x0276, r1
	}
	if(left_motor_speed>=255)
     6c2:	80 91 74 02 	lds	r24, 0x0274
     6c6:	90 91 75 02 	lds	r25, 0x0275
     6ca:	8f 3f       	cpi	r24, 0xFF	; 255
     6cc:	91 05       	cpc	r25, r1
     6ce:	34 f0       	brlt	.+12     	; 0x6dc <fw_control_motor_speed+0xb6>
	{
		left_motor_speed=255;
     6d0:	8f ef       	ldi	r24, 0xFF	; 255
     6d2:	90 e0       	ldi	r25, 0x00	; 0
     6d4:	90 93 75 02 	sts	0x0275, r25
     6d8:	80 93 74 02 	sts	0x0274, r24
	}
	if (right_motor_speed>=255)
     6dc:	80 91 76 02 	lds	r24, 0x0276
     6e0:	90 91 77 02 	lds	r25, 0x0277
     6e4:	8f 3f       	cpi	r24, 0xFF	; 255
     6e6:	91 05       	cpc	r25, r1
     6e8:	34 f0       	brlt	.+12     	; 0x6f6 <fw_control_motor_speed+0xd0>
	{
		right_motor_speed=255;
     6ea:	8f ef       	ldi	r24, 0xFF	; 255
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	90 93 77 02 	sts	0x0277, r25
     6f2:	80 93 76 02 	sts	0x0276, r24
	}
	forward();
     6f6:	0e 94 d6 02 	call	0x5ac	; 0x5ac <forward>
	velocity(left_motor_speed,right_motor_speed);
     6fa:	80 91 74 02 	lds	r24, 0x0274
     6fe:	60 91 76 02 	lds	r22, 0x0276
     702:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
}
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	ff 90       	pop	r15
     70c:	ef 90       	pop	r14
     70e:	df 90       	pop	r13
     710:	cf 90       	pop	r12
     712:	bf 90       	pop	r11
     714:	af 90       	pop	r10
     716:	9f 90       	pop	r9
     718:	8f 90       	pop	r8
     71a:	08 95       	ret

0000071c <black_line>:
* Logic: It will take the white sensor value and calculate the error which is then fed to the pid functions
* Example Call: black_line();
*/
void black_line()
{
	Left_white_line = ADC_Conversion(3);
     71c:	83 e0       	ldi	r24, 0x03	; 3
     71e:	0e 94 c7 00 	call	0x18e	; 0x18e <ADC_Conversion>
     722:	80 93 53 02 	sts	0x0253, r24
	Center_white_line = ADC_Conversion(2);
     726:	82 e0       	ldi	r24, 0x02	; 2
     728:	0e 94 c7 00 	call	0x18e	; 0x18e <ADC_Conversion>
     72c:	80 93 52 02 	sts	0x0252, r24
	Right_white_line = ADC_Conversion(1);
     730:	81 e0       	ldi	r24, 0x01	; 1
     732:	0e 94 c7 00 	call	0x18e	; 0x18e <ADC_Conversion>
     736:	80 93 51 02 	sts	0x0251, r24
	print_sensor(1,1,3);	//Prints value of White Line Sensor1
     73a:	81 e0       	ldi	r24, 0x01	; 1
     73c:	61 e0       	ldi	r22, 0x01	; 1
     73e:	43 e0       	ldi	r20, 0x03	; 3
     740:	0e 94 ff 02 	call	0x5fe	; 0x5fe <print_sensor>
	print_sensor(1,5,2);	//Prints Value of White Line Sensor2
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	65 e0       	ldi	r22, 0x05	; 5
     748:	42 e0       	ldi	r20, 0x02	; 2
     74a:	0e 94 ff 02 	call	0x5fe	; 0x5fe <print_sensor>
	print_sensor(1,9,1);	//Prints Value of White Line Sensor3
     74e:	81 e0       	ldi	r24, 0x01	; 1
     750:	69 e0       	ldi	r22, 0x09	; 9
     752:	41 e0       	ldi	r20, 0x01	; 1
     754:	0e 94 ff 02 	call	0x5fe	; 0x5fe <print_sensor>
	
	if(Left_white_line<=45 && Center_white_line<=16 && Right_white_line>46)
     758:	80 91 53 02 	lds	r24, 0x0253
     75c:	8e 32       	cpi	r24, 0x2E	; 46
     75e:	a8 f5       	brcc	.+106    	; 0x7ca <black_line+0xae>
     760:	90 91 52 02 	lds	r25, 0x0252
     764:	91 31       	cpi	r25, 0x11	; 17
     766:	88 f4       	brcc	.+34     	; 0x78a <black_line+0x6e>
     768:	20 91 51 02 	lds	r18, 0x0251
     76c:	2f 32       	cpi	r18, 0x2F	; 47
     76e:	68 f0       	brcs	.+26     	; 0x78a <black_line+0x6e>
	{
		error=2;
     770:	80 e0       	ldi	r24, 0x00	; 0
     772:	90 e0       	ldi	r25, 0x00	; 0
     774:	a0 e0       	ldi	r26, 0x00	; 0
     776:	b0 e4       	ldi	r27, 0x40	; 64
     778:	80 93 4d 02 	sts	0x024D, r24
     77c:	90 93 4e 02 	sts	0x024E, r25
     780:	a0 93 4f 02 	sts	0x024F, r26
     784:	b0 93 50 02 	sts	0x0250, r27
     788:	08 95       	ret
	}
	else if(Left_white_line<=45 && Center_white_line>46 && Right_white_line>46)
     78a:	9f 32       	cpi	r25, 0x2F	; 47
     78c:	f0 f0       	brcs	.+60     	; 0x7ca <black_line+0xae>
     78e:	90 91 51 02 	lds	r25, 0x0251
     792:	9f 32       	cpi	r25, 0x2F	; 47
     794:	08 f4       	brcc	.+2      	; 0x798 <black_line+0x7c>
     796:	77 c0       	rjmp	.+238    	; 0x886 <black_line+0x16a>
	{
		error=1;
     798:	80 e0       	ldi	r24, 0x00	; 0
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	a0 e8       	ldi	r26, 0x80	; 128
     79e:	bf e3       	ldi	r27, 0x3F	; 63
     7a0:	80 93 4d 02 	sts	0x024D, r24
     7a4:	90 93 4e 02 	sts	0x024E, r25
     7a8:	a0 93 4f 02 	sts	0x024F, r26
     7ac:	b0 93 50 02 	sts	0x0250, r27
     7b0:	08 95       	ret
	}
	else if(Left_white_line<=45 && Center_white_line>46 && Right_white_line<=45)
	{
		error=0;
     7b2:	80 e0       	ldi	r24, 0x00	; 0
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	dc 01       	movw	r26, r24
     7b8:	80 93 4d 02 	sts	0x024D, r24
     7bc:	90 93 4e 02 	sts	0x024E, r25
     7c0:	a0 93 4f 02 	sts	0x024F, r26
     7c4:	b0 93 50 02 	sts	0x0250, r27
     7c8:	08 95       	ret
	}
	else if(Left_white_line>46 && Center_white_line>46 && Right_white_line<=45)
     7ca:	8f 32       	cpi	r24, 0x2F	; 47
     7cc:	40 f1       	brcs	.+80     	; 0x81e <black_line+0x102>
     7ce:	90 91 52 02 	lds	r25, 0x0252
     7d2:	9f 32       	cpi	r25, 0x2F	; 47
     7d4:	88 f0       	brcs	.+34     	; 0x7f8 <black_line+0xdc>
     7d6:	20 91 51 02 	lds	r18, 0x0251
     7da:	2e 32       	cpi	r18, 0x2E	; 46
     7dc:	68 f4       	brcc	.+26     	; 0x7f8 <black_line+0xdc>
	{
		error=-1;
     7de:	80 e0       	ldi	r24, 0x00	; 0
     7e0:	90 e0       	ldi	r25, 0x00	; 0
     7e2:	a0 e8       	ldi	r26, 0x80	; 128
     7e4:	bf eb       	ldi	r27, 0xBF	; 191
     7e6:	80 93 4d 02 	sts	0x024D, r24
     7ea:	90 93 4e 02 	sts	0x024E, r25
     7ee:	a0 93 4f 02 	sts	0x024F, r26
     7f2:	b0 93 50 02 	sts	0x0250, r27
     7f6:	08 95       	ret
	}
	else if(Left_white_line>46 && Center_white_line<=45 && Right_white_line<=45)
     7f8:	9e 32       	cpi	r25, 0x2E	; 46
     7fa:	88 f4       	brcc	.+34     	; 0x81e <black_line+0x102>
     7fc:	90 91 51 02 	lds	r25, 0x0251
     800:	9e 32       	cpi	r25, 0x2E	; 46
     802:	68 f4       	brcc	.+26     	; 0x81e <black_line+0x102>
	{
		error=-2;
     804:	80 e0       	ldi	r24, 0x00	; 0
     806:	90 e0       	ldi	r25, 0x00	; 0
     808:	a0 e0       	ldi	r26, 0x00	; 0
     80a:	b0 ec       	ldi	r27, 0xC0	; 192
     80c:	80 93 4d 02 	sts	0x024D, r24
     810:	90 93 4e 02 	sts	0x024E, r25
     814:	a0 93 4f 02 	sts	0x024F, r26
     818:	b0 93 50 02 	sts	0x0250, r27
     81c:	08 95       	ret
	}
	else if(Left_white_line<=45 && Center_white_line<=45 && Right_white_line<=45)
     81e:	8e 32       	cpi	r24, 0x2E	; 46
     820:	c0 f5       	brcc	.+112    	; 0x892 <black_line+0x176>
     822:	80 91 52 02 	lds	r24, 0x0252
     826:	8e 32       	cpi	r24, 0x2E	; 46
     828:	a0 f5       	brcc	.+104    	; 0x892 <black_line+0x176>
     82a:	80 91 51 02 	lds	r24, 0x0251
     82e:	8e 32       	cpi	r24, 0x2E	; 46
     830:	80 f5       	brcc	.+96     	; 0x892 <black_line+0x176>
	{
		{
			if(error==-2)
     832:	60 91 4d 02 	lds	r22, 0x024D
     836:	70 91 4e 02 	lds	r23, 0x024E
     83a:	80 91 4f 02 	lds	r24, 0x024F
     83e:	90 91 50 02 	lds	r25, 0x0250
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	40 e0       	ldi	r20, 0x00	; 0
     848:	50 ec       	ldi	r21, 0xC0	; 192
     84a:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <__cmpsf2>
     84e:	88 23       	and	r24, r24
     850:	69 f4       	brne	.+26     	; 0x86c <black_line+0x150>
			{
				error=-3;
     852:	80 e0       	ldi	r24, 0x00	; 0
     854:	90 e0       	ldi	r25, 0x00	; 0
     856:	a0 e4       	ldi	r26, 0x40	; 64
     858:	b0 ec       	ldi	r27, 0xC0	; 192
     85a:	80 93 4d 02 	sts	0x024D, r24
     85e:	90 93 4e 02 	sts	0x024E, r25
     862:	a0 93 4f 02 	sts	0x024F, r26
     866:	b0 93 50 02 	sts	0x0250, r27
     86a:	08 95       	ret
			}
			else
			{
				error=3;
     86c:	80 e0       	ldi	r24, 0x00	; 0
     86e:	90 e0       	ldi	r25, 0x00	; 0
     870:	a0 e4       	ldi	r26, 0x40	; 64
     872:	b0 e4       	ldi	r27, 0x40	; 64
     874:	80 93 4d 02 	sts	0x024D, r24
     878:	90 93 4e 02 	sts	0x024E, r25
     87c:	a0 93 4f 02 	sts	0x024F, r26
     880:	b0 93 50 02 	sts	0x0250, r27
     884:	08 95       	ret
	}
	else if(Left_white_line<=45 && Center_white_line>46 && Right_white_line>46)
	{
		error=1;
	}
	else if(Left_white_line<=45 && Center_white_line>46 && Right_white_line<=45)
     886:	90 91 51 02 	lds	r25, 0x0251
     88a:	9e 32       	cpi	r25, 0x2E	; 46
     88c:	08 f0       	brcs	.+2      	; 0x890 <black_line+0x174>
     88e:	9d cf       	rjmp	.-198    	; 0x7ca <black_line+0xae>
     890:	90 cf       	rjmp	.-224    	; 0x7b2 <black_line+0x96>
     892:	08 95       	ret

00000894 <calculate_pid>:
* Output : none
* Logic: It calculates the pid value
* Example Call: calculate_pid();
*/
void calculate_pid()
{
     894:	4f 92       	push	r4
     896:	5f 92       	push	r5
     898:	6f 92       	push	r6
     89a:	7f 92       	push	r7
     89c:	8f 92       	push	r8
     89e:	9f 92       	push	r9
     8a0:	af 92       	push	r10
     8a2:	bf 92       	push	r11
     8a4:	cf 92       	push	r12
     8a6:	df 92       	push	r13
     8a8:	ef 92       	push	r14
     8aa:	ff 92       	push	r15
     8ac:	0f 93       	push	r16
     8ae:	1f 93       	push	r17
     8b0:	cf 93       	push	r28
     8b2:	df 93       	push	r29
	P = error;
     8b4:	c0 90 4d 02 	lds	r12, 0x024D
     8b8:	d0 90 4e 02 	lds	r13, 0x024E
     8bc:	e0 90 4f 02 	lds	r14, 0x024F
     8c0:	f0 90 50 02 	lds	r15, 0x0250
     8c4:	c0 92 49 02 	sts	0x0249, r12
     8c8:	d0 92 4a 02 	sts	0x024A, r13
     8cc:	e0 92 4b 02 	sts	0x024B, r14
     8d0:	f0 92 4c 02 	sts	0x024C, r15
	I = I + previous_I;
     8d4:	60 91 45 02 	lds	r22, 0x0245
     8d8:	70 91 46 02 	lds	r23, 0x0246
     8dc:	80 91 47 02 	lds	r24, 0x0247
     8e0:	90 91 48 02 	lds	r25, 0x0248
     8e4:	20 91 35 02 	lds	r18, 0x0235
     8e8:	30 91 36 02 	lds	r19, 0x0236
     8ec:	40 91 37 02 	lds	r20, 0x0237
     8f0:	50 91 38 02 	lds	r21, 0x0238
     8f4:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     8f8:	c6 2f       	mov	r28, r22
     8fa:	d7 2f       	mov	r29, r23
     8fc:	18 2f       	mov	r17, r24
     8fe:	09 2f       	mov	r16, r25
     900:	86 2f       	mov	r24, r22
     902:	9d 2f       	mov	r25, r29
     904:	a1 2f       	mov	r26, r17
     906:	b0 2f       	mov	r27, r16
     908:	80 93 45 02 	sts	0x0245, r24
     90c:	90 93 46 02 	sts	0x0246, r25
     910:	a0 93 47 02 	sts	0x0247, r26
     914:	b0 93 48 02 	sts	0x0248, r27
	D = error - previous_error;
     918:	c7 01       	movw	r24, r14
     91a:	b6 01       	movw	r22, r12
     91c:	20 91 39 02 	lds	r18, 0x0239
     920:	30 91 3a 02 	lds	r19, 0x023A
     924:	40 91 3b 02 	lds	r20, 0x023B
     928:	50 91 3c 02 	lds	r21, 0x023C
     92c:	0e 94 7e 11 	call	0x22fc	; 0x22fc <__subsf3>
     930:	b6 2e       	mov	r11, r22
     932:	a7 2e       	mov	r10, r23
     934:	98 2e       	mov	r9, r24
     936:	89 2e       	mov	r8, r25
     938:	86 2f       	mov	r24, r22
     93a:	9a 2d       	mov	r25, r10
     93c:	a9 2d       	mov	r26, r9
     93e:	b8 2d       	mov	r27, r8
     940:	80 93 41 02 	sts	0x0241, r24
     944:	90 93 42 02 	sts	0x0242, r25
     948:	a0 93 43 02 	sts	0x0243, r26
     94c:	b0 93 44 02 	sts	0x0244, r27
	
	PID_value = (Kp*P) + (Ki*I) + (Kd*D);
     950:	c7 01       	movw	r24, r14
     952:	b6 01       	movw	r22, r12
     954:	20 91 1a 02 	lds	r18, 0x021A
     958:	30 91 1b 02 	lds	r19, 0x021B
     95c:	40 91 1c 02 	lds	r20, 0x021C
     960:	50 91 1d 02 	lds	r21, 0x021D
     964:	0e 94 32 13 	call	0x2664	; 0x2664 <__mulsf3>
     968:	2b 01       	movw	r4, r22
     96a:	3c 01       	movw	r6, r24
     96c:	8c 2f       	mov	r24, r28
     96e:	9d 2f       	mov	r25, r29
     970:	a1 2f       	mov	r26, r17
     972:	b0 2f       	mov	r27, r16
     974:	bc 01       	movw	r22, r24
     976:	cd 01       	movw	r24, r26
     978:	20 91 16 02 	lds	r18, 0x0216
     97c:	30 91 17 02 	lds	r19, 0x0217
     980:	40 91 18 02 	lds	r20, 0x0218
     984:	50 91 19 02 	lds	r21, 0x0219
     988:	0e 94 32 13 	call	0x2664	; 0x2664 <__mulsf3>
     98c:	9b 01       	movw	r18, r22
     98e:	ac 01       	movw	r20, r24
     990:	c3 01       	movw	r24, r6
     992:	b2 01       	movw	r22, r4
     994:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     998:	2b 01       	movw	r4, r22
     99a:	3c 01       	movw	r6, r24
     99c:	8b 2d       	mov	r24, r11
     99e:	9a 2d       	mov	r25, r10
     9a0:	a9 2d       	mov	r26, r9
     9a2:	b8 2d       	mov	r27, r8
     9a4:	bc 01       	movw	r22, r24
     9a6:	cd 01       	movw	r24, r26
     9a8:	20 91 12 02 	lds	r18, 0x0212
     9ac:	30 91 13 02 	lds	r19, 0x0213
     9b0:	40 91 14 02 	lds	r20, 0x0214
     9b4:	50 91 15 02 	lds	r21, 0x0215
     9b8:	0e 94 32 13 	call	0x2664	; 0x2664 <__mulsf3>
     9bc:	9b 01       	movw	r18, r22
     9be:	ac 01       	movw	r20, r24
     9c0:	c3 01       	movw	r24, r6
     9c2:	b2 01       	movw	r22, r4
     9c4:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
     9c8:	dc 01       	movw	r26, r24
     9ca:	cb 01       	movw	r24, r22
     9cc:	80 93 3d 02 	sts	0x023D, r24
     9d0:	90 93 3e 02 	sts	0x023E, r25
     9d4:	a0 93 3f 02 	sts	0x023F, r26
     9d8:	b0 93 40 02 	sts	0x0240, r27
	
	previous_I=I;
     9dc:	8c 2f       	mov	r24, r28
     9de:	9d 2f       	mov	r25, r29
     9e0:	a1 2f       	mov	r26, r17
     9e2:	b0 2f       	mov	r27, r16
     9e4:	80 93 35 02 	sts	0x0235, r24
     9e8:	90 93 36 02 	sts	0x0236, r25
     9ec:	a0 93 37 02 	sts	0x0237, r26
     9f0:	b0 93 38 02 	sts	0x0238, r27
	previous_error=error;
     9f4:	c0 92 39 02 	sts	0x0239, r12
     9f8:	d0 92 3a 02 	sts	0x023A, r13
     9fc:	e0 92 3b 02 	sts	0x023B, r14
     a00:	f0 92 3c 02 	sts	0x023C, r15
}
     a04:	df 91       	pop	r29
     a06:	cf 91       	pop	r28
     a08:	1f 91       	pop	r17
     a0a:	0f 91       	pop	r16
     a0c:	ff 90       	pop	r15
     a0e:	ef 90       	pop	r14
     a10:	df 90       	pop	r13
     a12:	cf 90       	pop	r12
     a14:	bf 90       	pop	r11
     a16:	af 90       	pop	r10
     a18:	9f 90       	pop	r9
     a1a:	8f 90       	pop	r8
     a1c:	7f 90       	pop	r7
     a1e:	6f 90       	pop	r6
     a20:	5f 90       	pop	r5
     a22:	4f 90       	pop	r4
     a24:	08 95       	ret

00000a26 <fw_follow_black_line>:
*/
void fw_follow_black_line()	
 {
	while(1)
	{				
		black_line();
     a26:	0e 94 8e 03 	call	0x71c	; 0x71c <black_line>
		calculate_pid();
     a2a:	0e 94 4a 04 	call	0x894	; 0x894 <calculate_pid>
		fw_control_motor_speed();
     a2e:	0e 94 13 03 	call	0x626	; 0x626 <fw_control_motor_speed>
		if ((Left_white_line+Right_white_line+Center_white_line) >= 228)
     a32:	20 91 53 02 	lds	r18, 0x0253
     a36:	80 91 51 02 	lds	r24, 0x0251
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	82 0f       	add	r24, r18
     a3e:	91 1d       	adc	r25, r1
     a40:	20 91 52 02 	lds	r18, 0x0252
     a44:	82 0f       	add	r24, r18
     a46:	91 1d       	adc	r25, r1
     a48:	84 3e       	cpi	r24, 0xE4	; 228
     a4a:	91 05       	cpc	r25, r1
     a4c:	64 f3       	brlt	.-40     	; 0xa26 <fw_follow_black_line>
		{		//240 added
			buzzer_on();
     a4e:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
     a52:	89 e9       	ldi	r24, 0x99	; 153
     a54:	99 e5       	ldi	r25, 0x59	; 89
     a56:	a1 e0       	ldi	r26, 0x01	; 1
     a58:	81 50       	subi	r24, 0x01	; 1
     a5a:	90 40       	sbci	r25, 0x00	; 0
     a5c:	a0 40       	sbci	r26, 0x00	; 0
     a5e:	e1 f7       	brne	.-8      	; 0xa58 <fw_follow_black_line+0x32>
     a60:	00 00       	nop
			_delay_ms(30);
			buzzer_off();
     a62:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			break;
		}
	}
	stop();
     a66:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
     a6a:	08 95       	ret

00000a6c <init_devices>:
 * Logic:  Set the pins
 * Example Call: init_devices();
 */ 
void init_devices()
{
	cli(); //Clears the global interrupt
     a6c:	f8 94       	cli
	port_init();  //Initializes all the ports
     a6e:	0e 94 45 05 	call	0xa8a	; 0xa8a <port_init>
	left_position_encoder_interrupt_init();
     a72:	0e 94 95 00 	call	0x12a	; 0x12a <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     a76:	0e 94 9e 00 	call	0x13c	; 0x13c <right_position_encoder_interrupt_init>
	sei();   // Enables the global interrupt
     a7a:	78 94       	sei
}
     a7c:	08 95       	ret

00000a7e <left_encoder_pin_config>:
 * Logic: Set the direction of the PORTE pin 4 as input for the left position encoder
 * Example Call: left_encoder_pin_config();
 */ 
void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     a7e:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     a80:	74 9a       	sbi	0x0e, 4	; 14
}
     a82:	08 95       	ret

00000a84 <right_encoder_pin_config>:
 * Logic: Set the direction of the PORTE pin 5 as input for the left position encoder
 * Example Call: right_encoder_pin_config();
 */ 
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 5 pin as input
     a84:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 5 pin
     a86:	75 9a       	sbi	0x0e, 5	; 14
}
     a88:	08 95       	ret

00000a8a <port_init>:
 * Logic: Send the appropriate signals
 * Example Call: port_init(); 
 */ 
void port_init()
{
	motion_pin_config(); //robot motion pins config
     a8a:	0e 94 a4 02 	call	0x548	; 0x548 <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
     a8e:	0e 94 3f 05 	call	0xa7e	; 0xa7e <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
     a92:	0e 94 42 05 	call	0xa84	; 0xa84 <right_encoder_pin_config>
}
     a96:	08 95       	ret

00000a98 <__vector_6>:
 * Output :  increment right shaft position count
 * Logic: increment right shaft position count on detecting a pulse from the encoder 
 * Example Call:  None
 */ 
ISR(INT5_vect)
{
     a98:	1f 92       	push	r1
     a9a:	0f 92       	push	r0
     a9c:	0f b6       	in	r0, 0x3f	; 63
     a9e:	0f 92       	push	r0
     aa0:	11 24       	eor	r1, r1
     aa2:	8f 93       	push	r24
     aa4:	9f 93       	push	r25
     aa6:	af 93       	push	r26
     aa8:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
     aaa:	80 91 2d 02 	lds	r24, 0x022D
     aae:	90 91 2e 02 	lds	r25, 0x022E
     ab2:	a0 91 2f 02 	lds	r26, 0x022F
     ab6:	b0 91 30 02 	lds	r27, 0x0230
     aba:	01 96       	adiw	r24, 0x01	; 1
     abc:	a1 1d       	adc	r26, r1
     abe:	b1 1d       	adc	r27, r1
     ac0:	80 93 2d 02 	sts	0x022D, r24
     ac4:	90 93 2e 02 	sts	0x022E, r25
     ac8:	a0 93 2f 02 	sts	0x022F, r26
     acc:	b0 93 30 02 	sts	0x0230, r27
}
     ad0:	bf 91       	pop	r27
     ad2:	af 91       	pop	r26
     ad4:	9f 91       	pop	r25
     ad6:	8f 91       	pop	r24
     ad8:	0f 90       	pop	r0
     ada:	0f be       	out	0x3f, r0	; 63
     adc:	0f 90       	pop	r0
     ade:	1f 90       	pop	r1
     ae0:	18 95       	reti

00000ae2 <__vector_5>:
 * Output :  increment left shaft position count
 * Logic: increment left shaft position count on detecting a pulse from the encoder 
 * Example Call:  None
 */
ISR(INT4_vect)
{
     ae2:	1f 92       	push	r1
     ae4:	0f 92       	push	r0
     ae6:	0f b6       	in	r0, 0x3f	; 63
     ae8:	0f 92       	push	r0
     aea:	11 24       	eor	r1, r1
     aec:	8f 93       	push	r24
     aee:	9f 93       	push	r25
     af0:	af 93       	push	r26
     af2:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
     af4:	80 91 31 02 	lds	r24, 0x0231
     af8:	90 91 32 02 	lds	r25, 0x0232
     afc:	a0 91 33 02 	lds	r26, 0x0233
     b00:	b0 91 34 02 	lds	r27, 0x0234
     b04:	01 96       	adiw	r24, 0x01	; 1
     b06:	a1 1d       	adc	r26, r1
     b08:	b1 1d       	adc	r27, r1
     b0a:	80 93 31 02 	sts	0x0231, r24
     b0e:	90 93 32 02 	sts	0x0232, r25
     b12:	a0 93 33 02 	sts	0x0233, r26
     b16:	b0 93 34 02 	sts	0x0234, r27
}
     b1a:	bf 91       	pop	r27
     b1c:	af 91       	pop	r26
     b1e:	9f 91       	pop	r25
     b20:	8f 91       	pop	r24
     b22:	0f 90       	pop	r0
     b24:	0f be       	out	0x3f, r0	; 63
     b26:	0f 90       	pop	r0
     b28:	1f 90       	pop	r1
     b2a:	18 95       	reti

00000b2c <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
     b2c:	bc 01       	movw	r22, r24
     b2e:	80 e0       	ldi	r24, 0x00	; 0
     b30:	90 e0       	ldi	r25, 0x00	; 0
     b32:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
     b36:	25 ee       	ldi	r18, 0xE5	; 229
     b38:	30 ed       	ldi	r19, 0xD0	; 208
     b3a:	4a ea       	ldi	r20, 0xAA	; 170
     b3c:	50 e4       	ldi	r21, 0x40	; 64
     b3e:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     b42:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
     b46:	46 2f       	mov	r20, r22
     b48:	57 2f       	mov	r21, r23
     b4a:	68 2f       	mov	r22, r24
     b4c:	79 2f       	mov	r23, r25
	
	ShaftCountRight = 0;
     b4e:	10 92 2d 02 	sts	0x022D, r1
     b52:	10 92 2e 02 	sts	0x022E, r1
     b56:	10 92 2f 02 	sts	0x022F, r1
     b5a:	10 92 30 02 	sts	0x0230, r1
	while(1)
	{
		if(ShaftCountRight > ReqdShaftCountInt)
     b5e:	80 91 2d 02 	lds	r24, 0x022D
     b62:	90 91 2e 02 	lds	r25, 0x022E
     b66:	a0 91 2f 02 	lds	r26, 0x022F
     b6a:	b0 91 30 02 	lds	r27, 0x0230
     b6e:	48 17       	cp	r20, r24
     b70:	59 07       	cpc	r21, r25
     b72:	6a 07       	cpc	r22, r26
     b74:	7b 07       	cpc	r23, r27
     b76:	98 f7       	brcc	.-26     	; 0xb5e <linear_distance_mm+0x32>
		{
			break;
		}
	}
	stop(); //Stop robot
     b78:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
}
     b7c:	08 95       	ret

00000b7e <forward_mm>:
 * Output :  forward movement
 * Logic: Call forward function and linear_distance_mm 
 * Example Call: forward_mm(50);
 */ 
void forward_mm(unsigned int DistanceInMM)
{
     b7e:	cf 93       	push	r28
     b80:	df 93       	push	r29
     b82:	ec 01       	movw	r28, r24
	forward();
     b84:	0e 94 d6 02 	call	0x5ac	; 0x5ac <forward>
	linear_distance_mm(DistanceInMM);
     b88:	ce 01       	movw	r24, r28
     b8a:	0e 94 96 05 	call	0xb2c	; 0xb2c <linear_distance_mm>
}
     b8e:	df 91       	pop	r29
     b90:	cf 91       	pop	r28
     b92:	08 95       	ret

00000b94 <backward_mm>:
 * Input :  Distance to be travelled in mm
 * Output :  backward movement
 * Logic: Call back function and linear_distance_mm 
 * Example Call: backward_mm(50);
 */ 
void backward_mm(unsigned int DistanceInMM) {
     b94:	cf 93       	push	r28
     b96:	df 93       	push	r29
     b98:	ec 01       	movw	r28, r24
	back();
     b9a:	0e 94 da 02 	call	0x5b4	; 0x5b4 <back>
	linear_distance_mm(DistanceInMM);
     b9e:	ce 01       	movw	r24, r28
     ba0:	0e 94 96 05 	call	0xb2c	; 0xb2c <linear_distance_mm>
}
     ba4:	df 91       	pop	r29
     ba6:	cf 91       	pop	r28
     ba8:	08 95       	ret

00000baa <angle_rotate>:
 * Output : Firebird V rotates by specified degrees
 * Logic:  The slotted disc pins are counted
 * Example Call: angle_rotate(85,3);
 */ 
void angle_rotate(unsigned int Degrees,int k)
{
     baa:	2f 92       	push	r2
     bac:	3f 92       	push	r3
     bae:	4f 92       	push	r4
     bb0:	5f 92       	push	r5
     bb2:	6f 92       	push	r6
     bb4:	7f 92       	push	r7
     bb6:	8f 92       	push	r8
     bb8:	9f 92       	push	r9
     bba:	af 92       	push	r10
     bbc:	bf 92       	push	r11
     bbe:	cf 92       	push	r12
     bc0:	df 92       	push	r13
     bc2:	ef 92       	push	r14
     bc4:	ff 92       	push	r15
     bc6:	1f 93       	push	r17
     bc8:	cf 93       	push	r28
     bca:	df 93       	push	r29
     bcc:	d6 2f       	mov	r29, r22
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     bce:	bc 01       	movw	r22, r24
     bd0:	80 e0       	ldi	r24, 0x00	; 0
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
     bd8:	28 e4       	ldi	r18, 0x48	; 72
     bda:	31 ee       	ldi	r19, 0xE1	; 225
     bdc:	42 e8       	ldi	r20, 0x82	; 130
     bde:	50 e4       	ldi	r21, 0x40	; 64
     be0:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     be4:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
     be8:	2b 01       	movw	r4, r22
     bea:	66 24       	eor	r6, r6
     bec:	77 24       	eor	r7, r7
	ShaftCountRight = 0;
     bee:	10 92 2d 02 	sts	0x022D, r1
     bf2:	10 92 2e 02 	sts	0x022E, r1
     bf6:	10 92 2f 02 	sts	0x022F, r1
     bfa:	10 92 30 02 	sts	0x0230, r1
	ShaftCountLeft = 0;
     bfe:	10 92 31 02 	sts	0x0231, r1
     c02:	10 92 32 02 	sts	0x0232, r1
     c06:	10 92 33 02 	sts	0x0233, r1
     c0a:	10 92 34 02 	sts	0x0234, r1

	while (1)
	{
		
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt) | ADC_Conversion(k) > 55)
     c0e:	22 24       	eor	r2, r2
     c10:	33 24       	eor	r3, r3
     c12:	23 94       	inc	r2
     c14:	c1 e0       	ldi	r28, 0x01	; 1
     c16:	10 e0       	ldi	r17, 0x00	; 0
     c18:	c0 90 2d 02 	lds	r12, 0x022D
     c1c:	d0 90 2e 02 	lds	r13, 0x022E
     c20:	e0 90 2f 02 	lds	r14, 0x022F
     c24:	f0 90 30 02 	lds	r15, 0x0230
     c28:	80 90 31 02 	lds	r8, 0x0231
     c2c:	90 90 32 02 	lds	r9, 0x0232
     c30:	a0 90 33 02 	lds	r10, 0x0233
     c34:	b0 90 34 02 	lds	r11, 0x0234
     c38:	8d 2f       	mov	r24, r29
     c3a:	0e 94 c7 00 	call	0x18e	; 0x18e <ADC_Conversion>
     c3e:	91 01       	movw	r18, r2
     c40:	88 33       	cpi	r24, 0x38	; 56
     c42:	10 f4       	brcc	.+4      	; 0xc48 <angle_rotate+0x9e>
     c44:	20 e0       	ldi	r18, 0x00	; 0
     c46:	30 e0       	ldi	r19, 0x00	; 0
     c48:	9c 2f       	mov	r25, r28
     c4a:	c4 14       	cp	r12, r4
     c4c:	d5 04       	cpc	r13, r5
     c4e:	e6 04       	cpc	r14, r6
     c50:	f7 04       	cpc	r15, r7
     c52:	08 f4       	brcc	.+2      	; 0xc56 <angle_rotate+0xac>
     c54:	91 2f       	mov	r25, r17
     c56:	8c 2f       	mov	r24, r28
     c58:	84 14       	cp	r8, r4
     c5a:	95 04       	cpc	r9, r5
     c5c:	a6 04       	cpc	r10, r6
     c5e:	b7 04       	cpc	r11, r7
     c60:	08 f4       	brcc	.+2      	; 0xc64 <angle_rotate+0xba>
     c62:	81 2f       	mov	r24, r17
     c64:	89 2b       	or	r24, r25
     c66:	90 e0       	ldi	r25, 0x00	; 0
     c68:	28 2b       	or	r18, r24
     c6a:	39 2b       	or	r19, r25
     c6c:	21 15       	cp	r18, r1
     c6e:	31 05       	cpc	r19, r1
     c70:	99 f2       	breq	.-90     	; 0xc18 <angle_rotate+0x6e>
		break;
	}


	stop(); //Stop robot
     c72:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
}
     c76:	df 91       	pop	r29
     c78:	cf 91       	pop	r28
     c7a:	1f 91       	pop	r17
     c7c:	ff 90       	pop	r15
     c7e:	ef 90       	pop	r14
     c80:	df 90       	pop	r13
     c82:	cf 90       	pop	r12
     c84:	bf 90       	pop	r11
     c86:	af 90       	pop	r10
     c88:	9f 90       	pop	r9
     c8a:	8f 90       	pop	r8
     c8c:	7f 90       	pop	r7
     c8e:	6f 90       	pop	r6
     c90:	5f 90       	pop	r5
     c92:	4f 90       	pop	r4
     c94:	3f 90       	pop	r3
     c96:	2f 90       	pop	r2
     c98:	08 95       	ret

00000c9a <flag_angle_rotate>:
 * Output : Firebird V rotates by specified degrees
 * Logic:  The slotted disc pins are counted
 * Example Call: angle_rotate(85);
 */
void flag_angle_rotate(unsigned int Degrees)
{
     c9a:	0f 93       	push	r16
     c9c:	1f 93       	push	r17
     c9e:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     ca0:	bc 01       	movw	r22, r24
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
     caa:	28 e4       	ldi	r18, 0x48	; 72
     cac:	31 ee       	ldi	r19, 0xE1	; 225
     cae:	42 e8       	ldi	r20, 0x82	; 130
     cb0:	50 e4       	ldi	r21, 0x40	; 64
     cb2:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     cb6:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
     cba:	dc 01       	movw	r26, r24
     cbc:	cb 01       	movw	r24, r22
     cbe:	a0 e0       	ldi	r26, 0x00	; 0
     cc0:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
     cc2:	10 92 2d 02 	sts	0x022D, r1
     cc6:	10 92 2e 02 	sts	0x022E, r1
     cca:	10 92 2f 02 	sts	0x022F, r1
     cce:	10 92 30 02 	sts	0x0230, r1
	ShaftCountLeft = 0;
     cd2:	10 92 31 02 	sts	0x0231, r1
     cd6:	10 92 32 02 	sts	0x0232, r1
     cda:	10 92 33 02 	sts	0x0233, r1
     cde:	10 92 34 02 	sts	0x0234, r1

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     ce2:	f1 e0       	ldi	r31, 0x01	; 1
     ce4:	c0 e0       	ldi	r28, 0x00	; 0
     ce6:	40 91 2d 02 	lds	r20, 0x022D
     cea:	50 91 2e 02 	lds	r21, 0x022E
     cee:	60 91 2f 02 	lds	r22, 0x022F
     cf2:	70 91 30 02 	lds	r23, 0x0230
     cf6:	00 91 31 02 	lds	r16, 0x0231
     cfa:	10 91 32 02 	lds	r17, 0x0232
     cfe:	20 91 33 02 	lds	r18, 0x0233
     d02:	30 91 34 02 	lds	r19, 0x0234
     d06:	ef 2f       	mov	r30, r31
     d08:	48 17       	cp	r20, r24
     d0a:	59 07       	cpc	r21, r25
     d0c:	6a 07       	cpc	r22, r26
     d0e:	7b 07       	cpc	r23, r27
     d10:	08 f4       	brcc	.+2      	; 0xd14 <flag_angle_rotate+0x7a>
     d12:	ec 2f       	mov	r30, r28
     d14:	ee 23       	and	r30, r30
     d16:	49 f4       	brne	.+18     	; 0xd2a <flag_angle_rotate+0x90>
     d18:	4f 2f       	mov	r20, r31
     d1a:	08 17       	cp	r16, r24
     d1c:	19 07       	cpc	r17, r25
     d1e:	2a 07       	cpc	r18, r26
     d20:	3b 07       	cpc	r19, r27
     d22:	08 f4       	brcc	.+2      	; 0xd26 <flag_angle_rotate+0x8c>
     d24:	4c 2f       	mov	r20, r28
     d26:	44 23       	and	r20, r20
     d28:	f1 f2       	breq	.-68     	; 0xce6 <flag_angle_rotate+0x4c>
		break;
	}


	stop(); //Stop robot
     d2a:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
}
     d2e:	cf 91       	pop	r28
     d30:	1f 91       	pop	r17
     d32:	0f 91       	pop	r16
     d34:	08 95       	ret

00000d36 <left_degrees>:
 * Output : Firebird V rotates left by specified degrees
 * Logic:  The slotted disc pins are counted 
 * Example Call: left_degrees(85,1)
 */ 
void left_degrees(unsigned int Degrees,int flag)
{
     d36:	0f 93       	push	r16
     d38:	1f 93       	push	r17
     d3a:	cf 93       	push	r28
     d3c:	df 93       	push	r29
     d3e:	8c 01       	movw	r16, r24
     d40:	eb 01       	movw	r28, r22
	
	forward_mm(40);
     d42:	88 e2       	ldi	r24, 0x28	; 40
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
     d4a:	0e 94 de 02 	call	0x5bc	; 0x5bc <left>
     d4e:	8f ef       	ldi	r24, 0xFF	; 255
     d50:	9f e7       	ldi	r25, 0x7F	; 127
     d52:	ad e0       	ldi	r26, 0x0D	; 13
     d54:	81 50       	subi	r24, 0x01	; 1
     d56:	90 40       	sbci	r25, 0x00	; 0
     d58:	a0 40       	sbci	r26, 0x00	; 0
     d5a:	e1 f7       	brne	.-8      	; 0xd54 <left_degrees+0x1e>
     d5c:	00 c0       	rjmp	.+0      	; 0xd5e <left_degrees+0x28>
     d5e:	00 00       	nop
	_delay_ms(300);
	
	if(flag==0){
     d60:	20 97       	sbiw	r28, 0x00	; 0
     d62:	31 f4       	brne	.+12     	; 0xd70 <left_degrees+0x3a>
		angle_rotate(Degrees,3);		//normal rotation
     d64:	c8 01       	movw	r24, r16
     d66:	63 e0       	ldi	r22, 0x03	; 3
     d68:	70 e0       	ldi	r23, 0x00	; 0
     d6a:	0e 94 d5 05 	call	0xbaa	; 0xbaa <angle_rotate>
     d6e:	03 c0       	rjmp	.+6      	; 0xd76 <left_degrees+0x40>
	}
	else{
		flag_angle_rotate(Degrees);		//rotation at flag
     d70:	c8 01       	movw	r24, r16
     d72:	0e 94 4d 06 	call	0xc9a	; 0xc9a <flag_angle_rotate>
	}
	
	buzzer_on();
     d76:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
     d7a:	8f ef       	ldi	r24, 0xFF	; 255
     d7c:	9f e3       	ldi	r25, 0x3F	; 63
     d7e:	a2 e0       	ldi	r26, 0x02	; 2
     d80:	81 50       	subi	r24, 0x01	; 1
     d82:	90 40       	sbci	r25, 0x00	; 0
     d84:	a0 40       	sbci	r26, 0x00	; 0
     d86:	e1 f7       	brne	.-8      	; 0xd80 <left_degrees+0x4a>
     d88:	00 c0       	rjmp	.+0      	; 0xd8a <left_degrees+0x54>
     d8a:	00 00       	nop
	_delay_ms(50);
	buzzer_off();
     d8c:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>

	//adjust_bot(Left_white_line,Center_white_line,Right_white_line);

}
     d90:	df 91       	pop	r29
     d92:	cf 91       	pop	r28
     d94:	1f 91       	pop	r17
     d96:	0f 91       	pop	r16
     d98:	08 95       	ret

00000d9a <right_degrees>:
 * Output : Firebird V rotates right by specified degrees
 * Logic:  The slotted disc pins are counted 
 * Example Call: right_degrees(85,1)
 */
void right_degrees(unsigned int Degrees,int flag)
{
     d9a:	0f 93       	push	r16
     d9c:	1f 93       	push	r17
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
     da2:	8c 01       	movw	r16, r24
     da4:	eb 01       	movw	r28, r22
	
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	forward_mm(50);
     da6:	82 e3       	ldi	r24, 0x32	; 50
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
	right(); //Turn left
     dae:	0e 94 e2 02 	call	0x5c4	; 0x5c4 <right>
     db2:	8f ef       	ldi	r24, 0xFF	; 255
     db4:	9f e7       	ldi	r25, 0x7F	; 127
     db6:	ad e0       	ldi	r26, 0x0D	; 13
     db8:	81 50       	subi	r24, 0x01	; 1
     dba:	90 40       	sbci	r25, 0x00	; 0
     dbc:	a0 40       	sbci	r26, 0x00	; 0
     dbe:	e1 f7       	brne	.-8      	; 0xdb8 <right_degrees+0x1e>
     dc0:	00 c0       	rjmp	.+0      	; 0xdc2 <right_degrees+0x28>
     dc2:	00 00       	nop
	_delay_ms(300);
	if(flag==0){
     dc4:	20 97       	sbiw	r28, 0x00	; 0
     dc6:	31 f4       	brne	.+12     	; 0xdd4 <right_degrees+0x3a>
		angle_rotate(Degrees,1);		//normal rotation
     dc8:	c8 01       	movw	r24, r16
     dca:	61 e0       	ldi	r22, 0x01	; 1
     dcc:	70 e0       	ldi	r23, 0x00	; 0
     dce:	0e 94 d5 05 	call	0xbaa	; 0xbaa <angle_rotate>
     dd2:	03 c0       	rjmp	.+6      	; 0xdda <right_degrees+0x40>
	}
	else{
		flag_angle_rotate(Degrees);		//rotation at flag
     dd4:	c8 01       	movw	r24, r16
     dd6:	0e 94 4d 06 	call	0xc9a	; 0xc9a <flag_angle_rotate>
	}
	buzzer_on();
     dda:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
     dde:	8f ef       	ldi	r24, 0xFF	; 255
     de0:	9f e3       	ldi	r25, 0x3F	; 63
     de2:	a2 e0       	ldi	r26, 0x02	; 2
     de4:	81 50       	subi	r24, 0x01	; 1
     de6:	90 40       	sbci	r25, 0x00	; 0
     de8:	a0 40       	sbci	r26, 0x00	; 0
     dea:	e1 f7       	brne	.-8      	; 0xde4 <right_degrees+0x4a>
     dec:	00 c0       	rjmp	.+0      	; 0xdee <right_degrees+0x54>
     dee:	00 00       	nop
	_delay_ms(50);
	buzzer_off();
     df0:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>


	//adjust_bot(Left_white_line,Center_white_line,Right_white_line);

}
     df4:	df 91       	pop	r29
     df6:	cf 91       	pop	r28
     df8:	1f 91       	pop	r17
     dfa:	0f 91       	pop	r16
     dfc:	08 95       	ret

00000dfe <rotate_at_flag>:
 * Output : Brings the robot in front of the flag to sense its color
 * Logic: perform proper rotations and movements 
 * Example Call:  rotate_at_flag();
 */ 
void rotate_at_flag() {
	velocity(180,180);
     dfe:	84 eb       	ldi	r24, 0xB4	; 180
     e00:	64 eb       	ldi	r22, 0xB4	; 180
     e02:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
	left_degrees(88,1);//105
     e06:	88 e5       	ldi	r24, 0x58	; 88
     e08:	90 e0       	ldi	r25, 0x00	; 0
     e0a:	61 e0       	ldi	r22, 0x01	; 1
     e0c:	70 e0       	ldi	r23, 0x00	; 0
     e0e:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
	forward_mm(20);//30
     e12:	84 e1       	ldi	r24, 0x14	; 20
     e14:	90 e0       	ldi	r25, 0x00	; 0
     e16:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
	velocity(180,180);
     e1a:	84 eb       	ldi	r24, 0xB4	; 180
     e1c:	64 eb       	ldi	r22, 0xB4	; 180
     e1e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
	right_degrees(195,1);//195/178
     e22:	83 ec       	ldi	r24, 0xC3	; 195
     e24:	90 e0       	ldi	r25, 0x00	; 0
     e26:	61 e0       	ldi	r22, 0x01	; 1
     e28:	70 e0       	ldi	r23, 0x00	; 0
     e2a:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
	forward_mm(5);//19
     e2e:	85 e0       	ldi	r24, 0x05	; 5
     e30:	90 e0       	ldi	r25, 0x00	; 0
     e32:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
     e36:	8f ef       	ldi	r24, 0xFF	; 255
     e38:	9f e7       	ldi	r25, 0x7F	; 127
     e3a:	a6 e1       	ldi	r26, 0x16	; 22
     e3c:	81 50       	subi	r24, 0x01	; 1
     e3e:	90 40       	sbci	r25, 0x00	; 0
     e40:	a0 40       	sbci	r26, 0x00	; 0
     e42:	e1 f7       	brne	.-8      	; 0xe3c <rotate_at_flag+0x3e>
     e44:	00 c0       	rjmp	.+0      	; 0xe46 <rotate_at_flag+0x48>
     e46:	00 00       	nop
	_delay_ms(500);
	stop();
     e48:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
	velocity(255,255);	
     e4c:	8f ef       	ldi	r24, 0xFF	; 255
     e4e:	6f ef       	ldi	r22, 0xFF	; 255
     e50:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
}
     e54:	08 95       	ret

00000e56 <soft_left_degrees>:
 * Output : Firebird V rotates softly left by specified degrees
 * Logic:  The slotted disc pins are counted 
 * Example Call: soft_left_degrees(85)
 */
void soft_left_degrees(unsigned int Degrees)
{
     e56:	cf 93       	push	r28
     e58:	df 93       	push	r29
     e5a:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
     e5c:	0e 94 e6 02 	call	0x5cc	; 0x5cc <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees,3);
     e60:	ce 01       	movw	r24, r28
     e62:	88 0f       	add	r24, r24
     e64:	99 1f       	adc	r25, r25
     e66:	63 e0       	ldi	r22, 0x03	; 3
     e68:	70 e0       	ldi	r23, 0x00	; 0
     e6a:	0e 94 d5 05 	call	0xbaa	; 0xbaa <angle_rotate>
}
     e6e:	df 91       	pop	r29
     e70:	cf 91       	pop	r28
     e72:	08 95       	ret

00000e74 <soft_right_degrees>:
 * Output : Firebird V rotates softly right by specified degrees
 * Logic:  The slotted disc pins are counted 
 * Example Call: soft_right_degrees(85)
 */
void soft_right_degrees(unsigned int Degrees)
{
     e74:	cf 93       	push	r28
     e76:	df 93       	push	r29
     e78:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right(); //Turn soft right
     e7a:	0e 94 ee 02 	call	0x5dc	; 0x5dc <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees,1);
     e7e:	ce 01       	movw	r24, r28
     e80:	88 0f       	add	r24, r24
     e82:	99 1f       	adc	r25, r25
     e84:	61 e0       	ldi	r22, 0x01	; 1
     e86:	70 e0       	ldi	r23, 0x00	; 0
     e88:	0e 94 d5 05 	call	0xbaa	; 0xbaa <angle_rotate>
}
     e8c:	df 91       	pop	r29
     e8e:	cf 91       	pop	r28
     e90:	08 95       	ret

00000e92 <soft_left_2_degrees>:
 * Output : Firebird V rotates softly left by specified degrees
 * Logic:  The slotted disc pins are counted 
 * Example Call: soft_left_2_degrees(85)
 */
void soft_left_2_degrees(unsigned int Degrees)
{
     e92:	cf 93       	push	r28
     e94:	df 93       	push	r29
     e96:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left_2(); //Turn reverse soft left
     e98:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <soft_left_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees,3);
     e9c:	ce 01       	movw	r24, r28
     e9e:	88 0f       	add	r24, r24
     ea0:	99 1f       	adc	r25, r25
     ea2:	63 e0       	ldi	r22, 0x03	; 3
     ea4:	70 e0       	ldi	r23, 0x00	; 0
     ea6:	0e 94 d5 05 	call	0xbaa	; 0xbaa <angle_rotate>
}
     eaa:	df 91       	pop	r29
     eac:	cf 91       	pop	r28
     eae:	08 95       	ret

00000eb0 <soft_right_2_degrees>:
 * Output : Firebird V rotates softly right by specified degrees
 * Logic:  The slotted disc pins are counted 
 * Example Call: soft_right_2_degrees(85)
 */
void soft_right_2_degrees(unsigned int Degrees)
{
     eb0:	cf 93       	push	r28
     eb2:	df 93       	push	r29
     eb4:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right_2(); //Turn reverse soft right
     eb6:	0e 94 f6 02 	call	0x5ec	; 0x5ec <soft_right_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees,1);
     eba:	ce 01       	movw	r24, r28
     ebc:	88 0f       	add	r24, r24
     ebe:	99 1f       	adc	r25, r25
     ec0:	61 e0       	ldi	r22, 0x01	; 1
     ec2:	70 e0       	ldi	r23, 0x00	; 0
     ec4:	0e 94 d5 05 	call	0xbaa	; 0xbaa <angle_rotate>
     ec8:	df 91       	pop	r29
     eca:	cf 91       	pop	r28
     ecc:	08 95       	ret

00000ece <lcd_set_4bit>:
     ece:	86 e6       	ldi	r24, 0x66	; 102
     ed0:	9e e0       	ldi	r25, 0x0E	; 14
     ed2:	01 97       	sbiw	r24, 0x01	; 1
     ed4:	f1 f7       	brne	.-4      	; 0xed2 <lcd_set_4bit+0x4>
     ed6:	00 00       	nop
 */ 
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				
     ed8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				
     eda:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				
     edc:	80 e3       	ldi	r24, 0x30	; 48
     ede:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				
     ee0:	42 9a       	sbi	0x08, 2	; 8
     ee2:	ef ef       	ldi	r30, 0xFF	; 255
     ee4:	f7 e4       	ldi	r31, 0x47	; 71
     ee6:	31 97       	sbiw	r30, 0x01	; 1
     ee8:	f1 f7       	brne	.-4      	; 0xee6 <lcd_set_4bit+0x18>
     eea:	00 c0       	rjmp	.+0      	; 0xeec <lcd_set_4bit+0x1e>
     eec:	00 00       	nop
	_delay_ms(5);					
	cbit(lcd_port,EN);				
     eee:	42 98       	cbi	0x08, 2	; 8
     ef0:	e6 e6       	ldi	r30, 0x66	; 102
     ef2:	fe e0       	ldi	r31, 0x0E	; 14
     ef4:	31 97       	sbiw	r30, 0x01	; 1
     ef6:	f1 f7       	brne	.-4      	; 0xef4 <lcd_set_4bit+0x26>
     ef8:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				
     efa:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				
     efc:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				
     efe:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				
     f00:	42 9a       	sbi	0x08, 2	; 8
     f02:	ef ef       	ldi	r30, 0xFF	; 255
     f04:	f7 e4       	ldi	r31, 0x47	; 71
     f06:	31 97       	sbiw	r30, 0x01	; 1
     f08:	f1 f7       	brne	.-4      	; 0xf06 <lcd_set_4bit+0x38>
     f0a:	00 c0       	rjmp	.+0      	; 0xf0c <lcd_set_4bit+0x3e>
     f0c:	00 00       	nop
	_delay_ms(5);					
	cbit(lcd_port,EN);				
     f0e:	42 98       	cbi	0x08, 2	; 8
     f10:	e6 e6       	ldi	r30, 0x66	; 102
     f12:	fe e0       	ldi	r31, 0x0E	; 14
     f14:	31 97       	sbiw	r30, 0x01	; 1
     f16:	f1 f7       	brne	.-4      	; 0xf14 <lcd_set_4bit+0x46>
     f18:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				
     f1a:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				
     f1c:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				
     f1e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				
     f20:	42 9a       	sbi	0x08, 2	; 8
     f22:	8f ef       	ldi	r24, 0xFF	; 255
     f24:	97 e4       	ldi	r25, 0x47	; 71
     f26:	01 97       	sbiw	r24, 0x01	; 1
     f28:	f1 f7       	brne	.-4      	; 0xf26 <lcd_set_4bit+0x58>
     f2a:	00 c0       	rjmp	.+0      	; 0xf2c <lcd_set_4bit+0x5e>
     f2c:	00 00       	nop
	_delay_ms(5);					
	cbit(lcd_port,EN);				
     f2e:	42 98       	cbi	0x08, 2	; 8
     f30:	e6 e6       	ldi	r30, 0x66	; 102
     f32:	fe e0       	ldi	r31, 0x0E	; 14
     f34:	31 97       	sbiw	r30, 0x01	; 1
     f36:	f1 f7       	brne	.-4      	; 0xf34 <lcd_set_4bit+0x66>
     f38:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				
     f3a:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				
     f3c:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				
     f3e:	80 e2       	ldi	r24, 0x20	; 32
     f40:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				
     f42:	42 9a       	sbi	0x08, 2	; 8
     f44:	8f ef       	ldi	r24, 0xFF	; 255
     f46:	97 e4       	ldi	r25, 0x47	; 71
     f48:	01 97       	sbiw	r24, 0x01	; 1
     f4a:	f1 f7       	brne	.-4      	; 0xf48 <lcd_set_4bit+0x7a>
     f4c:	00 c0       	rjmp	.+0      	; 0xf4e <lcd_set_4bit+0x80>
     f4e:	00 00       	nop
	_delay_ms(5);					
	cbit(lcd_port,EN);					
     f50:	42 98       	cbi	0x08, 2	; 8
}
     f52:	08 95       	ret

00000f54 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     f54:	98 b1       	in	r25, 0x08	; 8
     f56:	9f 70       	andi	r25, 0x0F	; 15
     f58:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     f5a:	98 b1       	in	r25, 0x08	; 8
 */ 	 
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     f5c:	28 2f       	mov	r18, r24
     f5e:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     f60:	92 2b       	or	r25, r18
     f62:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     f64:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     f66:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     f68:	42 9a       	sbi	0x08, 2	; 8
     f6a:	ef ef       	ldi	r30, 0xFF	; 255
     f6c:	f7 e4       	ldi	r31, 0x47	; 71
     f6e:	31 97       	sbiw	r30, 0x01	; 1
     f70:	f1 f7       	brne	.-4      	; 0xf6e <lcd_wr_command+0x1a>
     f72:	00 c0       	rjmp	.+0      	; 0xf74 <lcd_wr_command+0x20>
     f74:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     f76:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     f78:	98 b1       	in	r25, 0x08	; 8
     f7a:	9f 70       	andi	r25, 0x0F	; 15
     f7c:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     f7e:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     f80:	82 95       	swap	r24
     f82:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     f84:	89 2b       	or	r24, r25
     f86:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     f88:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     f8a:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     f8c:	42 9a       	sbi	0x08, 2	; 8
     f8e:	8f ef       	ldi	r24, 0xFF	; 255
     f90:	97 e4       	ldi	r25, 0x47	; 71
     f92:	01 97       	sbiw	r24, 0x01	; 1
     f94:	f1 f7       	brne	.-4      	; 0xf92 <lcd_wr_command+0x3e>
     f96:	00 c0       	rjmp	.+0      	; 0xf98 <lcd_wr_command+0x44>
     f98:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     f9a:	42 98       	cbi	0x08, 2	; 8
}
     f9c:	08 95       	ret

00000f9e <lcd_cursor>:
 * Logic: Send command signals to the lcd
 * Example Call: lcd_cursor (1,2)
 */ 
void lcd_cursor (char row, char column)
{
	switch (row) {
     f9e:	82 30       	cpi	r24, 0x02	; 2
     fa0:	79 f0       	breq	.+30     	; 0xfc0 <lcd_cursor+0x22>
     fa2:	83 30       	cpi	r24, 0x03	; 3
     fa4:	18 f4       	brcc	.+6      	; 0xfac <lcd_cursor+0xe>
     fa6:	81 30       	cpi	r24, 0x01	; 1
     fa8:	c9 f4       	brne	.+50     	; 0xfdc <lcd_cursor+0x3e>
     faa:	05 c0       	rjmp	.+10     	; 0xfb6 <lcd_cursor+0x18>
     fac:	83 30       	cpi	r24, 0x03	; 3
     fae:	69 f0       	breq	.+26     	; 0xfca <lcd_cursor+0x2c>
     fb0:	84 30       	cpi	r24, 0x04	; 4
     fb2:	a1 f4       	brne	.+40     	; 0xfdc <lcd_cursor+0x3e>
     fb4:	0f c0       	rjmp	.+30     	; 0xfd4 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     fb6:	86 2f       	mov	r24, r22
     fb8:	81 58       	subi	r24, 0x81	; 129
     fba:	0e 94 aa 07 	call	0xf54	; 0xf54 <lcd_wr_command>
     fbe:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     fc0:	86 2f       	mov	r24, r22
     fc2:	81 54       	subi	r24, 0x41	; 65
     fc4:	0e 94 aa 07 	call	0xf54	; 0xf54 <lcd_wr_command>
     fc8:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     fca:	86 2f       	mov	r24, r22
     fcc:	8d 56       	subi	r24, 0x6D	; 109
     fce:	0e 94 aa 07 	call	0xf54	; 0xf54 <lcd_wr_command>
     fd2:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     fd4:	86 2f       	mov	r24, r22
     fd6:	8d 52       	subi	r24, 0x2D	; 45
     fd8:	0e 94 aa 07 	call	0xf54	; 0xf54 <lcd_wr_command>
     fdc:	08 95       	ret

00000fde <lcd_init>:
 * Logic: call the functions to initialize the lcd 
 * Example Call: lcd_init();
 */ 
void lcd_init()
{
	lcd_set_4bit();
     fde:	0e 94 67 07 	call	0xece	; 0xece <lcd_set_4bit>
     fe2:	86 e6       	ldi	r24, 0x66	; 102
     fe4:	9e e0       	ldi	r25, 0x0E	; 14
     fe6:	01 97       	sbiw	r24, 0x01	; 1
     fe8:	f1 f7       	brne	.-4      	; 0xfe6 <lcd_init+0x8>
     fea:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			
     fec:	88 e2       	ldi	r24, 0x28	; 40
     fee:	0e 94 aa 07 	call	0xf54	; 0xf54 <lcd_wr_command>
	lcd_wr_command(0x01);
     ff2:	81 e0       	ldi	r24, 0x01	; 1
     ff4:	0e 94 aa 07 	call	0xf54	; 0xf54 <lcd_wr_command>
	lcd_wr_command(0x06);
     ff8:	86 e0       	ldi	r24, 0x06	; 6
     ffa:	0e 94 aa 07 	call	0xf54	; 0xf54 <lcd_wr_command>
	lcd_wr_command(0x0E);
     ffe:	8e e0       	ldi	r24, 0x0E	; 14
    1000:	0e 94 aa 07 	call	0xf54	; 0xf54 <lcd_wr_command>
	lcd_wr_command(0x80);
    1004:	80 e8       	ldi	r24, 0x80	; 128
    1006:	0e 94 aa 07 	call	0xf54	; 0xf54 <lcd_wr_command>
		
}
    100a:	08 95       	ret

0000100c <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
    100c:	98 b1       	in	r25, 0x08	; 8
    100e:	9f 70       	andi	r25, 0x0F	; 15
    1010:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
    1012:	98 b1       	in	r25, 0x08	; 8
 */
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
    1014:	28 2f       	mov	r18, r24
    1016:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
    1018:	92 2b       	or	r25, r18
    101a:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
    101c:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
    101e:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
    1020:	42 9a       	sbi	0x08, 2	; 8
    1022:	ef ef       	ldi	r30, 0xFF	; 255
    1024:	f7 e4       	ldi	r31, 0x47	; 71
    1026:	31 97       	sbiw	r30, 0x01	; 1
    1028:	f1 f7       	brne	.-4      	; 0x1026 <lcd_wr_char+0x1a>
    102a:	00 c0       	rjmp	.+0      	; 0x102c <lcd_wr_char+0x20>
    102c:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
    102e:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
    1030:	98 b1       	in	r25, 0x08	; 8
    1032:	9f 70       	andi	r25, 0x0F	; 15
    1034:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
    1036:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
    1038:	82 95       	swap	r24
    103a:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
    103c:	89 2b       	or	r24, r25
    103e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
    1040:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
    1042:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
    1044:	42 9a       	sbi	0x08, 2	; 8
    1046:	8f ef       	ldi	r24, 0xFF	; 255
    1048:	97 e4       	ldi	r25, 0x47	; 71
    104a:	01 97       	sbiw	r24, 0x01	; 1
    104c:	f1 f7       	brne	.-4      	; 0x104a <lcd_wr_char+0x3e>
    104e:	00 c0       	rjmp	.+0      	; 0x1050 <lcd_wr_char+0x44>
    1050:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
    1052:	42 98       	cbi	0x08, 2	; 8
}
    1054:	08 95       	ret

00001056 <lcd_string>:
 * Output : Prints String on LCD   
 * Logic: Write string to LCD 
 * Example Call: lcd_string("Green"); 
 */
void lcd_string(char *str)
{
    1056:	cf 93       	push	r28
    1058:	df 93       	push	r29
    105a:	ec 01       	movw	r28, r24
	while(*str != '\0')
    105c:	88 81       	ld	r24, Y
    105e:	88 23       	and	r24, r24
    1060:	31 f0       	breq	.+12     	; 0x106e <lcd_string+0x18>
 * Input : Char type string str
 * Output : Prints String on LCD   
 * Logic: Write string to LCD 
 * Example Call: lcd_string("Green"); 
 */
void lcd_string(char *str)
    1062:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
    1064:	0e 94 06 08 	call	0x100c	; 0x100c <lcd_wr_char>
 * Logic: Write string to LCD 
 * Example Call: lcd_string("Green"); 
 */
void lcd_string(char *str)
{
	while(*str != '\0')
    1068:	89 91       	ld	r24, Y+
    106a:	88 23       	and	r24, r24
    106c:	d9 f7       	brne	.-10     	; 0x1064 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
    106e:	df 91       	pop	r29
    1070:	cf 91       	pop	r28
    1072:	08 95       	ret

00001074 <lcd_home>:
 * Logic: send 0x80 command to LCD to bring cursor at home position 
 * Example Call: lcd_home(); 
 */
void lcd_home()
{
	lcd_wr_command(0x80);
    1074:	80 e8       	ldi	r24, 0x80	; 128
    1076:	0e 94 aa 07 	call	0xf54	; 0xf54 <lcd_wr_command>
}
    107a:	08 95       	ret

0000107c <lcd_print>:
 * Logic: send write signals to lcd
 * Example Call: lcd_print (1,2,23,3)
 */ 
//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
    107c:	0f 93       	push	r16
    107e:	1f 93       	push	r17
    1080:	cf 93       	push	r28
    1082:	df 93       	push	r29
    1084:	8a 01       	movw	r16, r20
    1086:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
    1088:	88 23       	and	r24, r24
    108a:	11 f0       	breq	.+4      	; 0x1090 <lcd_print+0x14>
    108c:	66 23       	and	r22, r22
    108e:	19 f4       	brne	.+6      	; 0x1096 <lcd_print+0x1a>
	{
		lcd_home();
    1090:	0e 94 3a 08 	call	0x1074	; 0x1074 <lcd_home>
    1094:	02 c0       	rjmp	.+4      	; 0x109a <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
    1096:	0e 94 cf 07 	call	0xf9e	; 0xf9e <lcd_cursor>
	}
	if(digits==5 || flag==1)
    109a:	c5 30       	cpi	r28, 0x05	; 5
    109c:	d1 05       	cpc	r29, r1
    109e:	71 f4       	brne	.+28     	; 0x10bc <lcd_print+0x40>
	{
		million=value/10000+48;
    10a0:	c8 01       	movw	r24, r16
    10a2:	60 e1       	ldi	r22, 0x10	; 16
    10a4:	77 e2       	ldi	r23, 0x27	; 39
    10a6:	0e 94 95 13 	call	0x272a	; 0x272a <__udivmodhi4>
    10aa:	cb 01       	movw	r24, r22
    10ac:	c0 96       	adiw	r24, 0x30	; 48
    10ae:	90 93 5f 02 	sts	0x025F, r25
    10b2:	80 93 5e 02 	sts	0x025E, r24
		lcd_wr_char(million);
    10b6:	0e 94 06 08 	call	0x100c	; 0x100c <lcd_wr_char>
    10ba:	03 c0       	rjmp	.+6      	; 0x10c2 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
    10bc:	c4 30       	cpi	r28, 0x04	; 4
    10be:	d1 05       	cpc	r29, r1
    10c0:	b9 f4       	brne	.+46     	; 0x10f0 <lcd_print+0x74>
	{
		temp = value/1000;
    10c2:	c8 01       	movw	r24, r16
    10c4:	68 ee       	ldi	r22, 0xE8	; 232
    10c6:	73 e0       	ldi	r23, 0x03	; 3
    10c8:	0e 94 95 13 	call	0x272a	; 0x272a <__udivmodhi4>
    10cc:	cb 01       	movw	r24, r22
    10ce:	70 93 61 02 	sts	0x0261, r23
    10d2:	60 93 60 02 	sts	0x0260, r22
		thousand = temp%10 + 48;
    10d6:	6a e0       	ldi	r22, 0x0A	; 10
    10d8:	70 e0       	ldi	r23, 0x00	; 0
    10da:	0e 94 95 13 	call	0x272a	; 0x272a <__udivmodhi4>
    10de:	c0 96       	adiw	r24, 0x30	; 48
    10e0:	90 93 7d 02 	sts	0x027D, r25
    10e4:	80 93 7c 02 	sts	0x027C, r24
		lcd_wr_char(thousand);
    10e8:	0e 94 06 08 	call	0x100c	; 0x100c <lcd_wr_char>
		flag=1;
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	01 c0       	rjmp	.+2      	; 0x10f2 <lcd_print+0x76>
 * Example Call: lcd_print (1,2,23,3)
 */ 
//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
    10f0:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
    10f2:	c3 30       	cpi	r28, 0x03	; 3
    10f4:	d1 05       	cpc	r29, r1
    10f6:	11 f0       	breq	.+4      	; 0x10fc <lcd_print+0x80>
    10f8:	81 30       	cpi	r24, 0x01	; 1
    10fa:	b1 f4       	brne	.+44     	; 0x1128 <lcd_print+0xac>
	{
		temp = value/100;
    10fc:	c8 01       	movw	r24, r16
    10fe:	64 e6       	ldi	r22, 0x64	; 100
    1100:	70 e0       	ldi	r23, 0x00	; 0
    1102:	0e 94 95 13 	call	0x272a	; 0x272a <__udivmodhi4>
    1106:	cb 01       	movw	r24, r22
    1108:	70 93 61 02 	sts	0x0261, r23
    110c:	60 93 60 02 	sts	0x0260, r22
		hundred = temp%10 + 48;
    1110:	6a e0       	ldi	r22, 0x0A	; 10
    1112:	70 e0       	ldi	r23, 0x00	; 0
    1114:	0e 94 95 13 	call	0x272a	; 0x272a <__udivmodhi4>
    1118:	c0 96       	adiw	r24, 0x30	; 48
    111a:	90 93 79 02 	sts	0x0279, r25
    111e:	80 93 78 02 	sts	0x0278, r24
		lcd_wr_char(hundred);
    1122:	0e 94 06 08 	call	0x100c	; 0x100c <lcd_wr_char>
		flag=1;
    1126:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
    1128:	c2 30       	cpi	r28, 0x02	; 2
    112a:	d1 05       	cpc	r29, r1
    112c:	11 f0       	breq	.+4      	; 0x1132 <lcd_print+0xb6>
    112e:	81 30       	cpi	r24, 0x01	; 1
    1130:	b1 f4       	brne	.+44     	; 0x115e <lcd_print+0xe2>
	{
		temp = value/10;
    1132:	2a e0       	ldi	r18, 0x0A	; 10
    1134:	30 e0       	ldi	r19, 0x00	; 0
    1136:	c8 01       	movw	r24, r16
    1138:	b9 01       	movw	r22, r18
    113a:	0e 94 95 13 	call	0x272a	; 0x272a <__udivmodhi4>
    113e:	cb 01       	movw	r24, r22
    1140:	70 93 61 02 	sts	0x0261, r23
    1144:	60 93 60 02 	sts	0x0260, r22
		tens = temp%10 + 48;
    1148:	b9 01       	movw	r22, r18
    114a:	0e 94 95 13 	call	0x272a	; 0x272a <__udivmodhi4>
    114e:	c0 96       	adiw	r24, 0x30	; 48
    1150:	90 93 73 02 	sts	0x0273, r25
    1154:	80 93 72 02 	sts	0x0272, r24
		lcd_wr_char(tens);
    1158:	0e 94 06 08 	call	0x100c	; 0x100c <lcd_wr_char>
		flag=1;
    115c:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
    115e:	c1 30       	cpi	r28, 0x01	; 1
    1160:	d1 05       	cpc	r29, r1
    1162:	11 f0       	breq	.+4      	; 0x1168 <lcd_print+0xec>
    1164:	81 30       	cpi	r24, 0x01	; 1
    1166:	61 f4       	brne	.+24     	; 0x1180 <lcd_print+0x104>
	{
		unit = value%10 + 48;
    1168:	c8 01       	movw	r24, r16
    116a:	6a e0       	ldi	r22, 0x0A	; 10
    116c:	70 e0       	ldi	r23, 0x00	; 0
    116e:	0e 94 95 13 	call	0x272a	; 0x272a <__udivmodhi4>
    1172:	c0 96       	adiw	r24, 0x30	; 48
    1174:	90 93 7b 02 	sts	0x027B, r25
    1178:	80 93 7a 02 	sts	0x027A, r24
		lcd_wr_char(unit);
    117c:	0e 94 06 08 	call	0x100c	; 0x100c <lcd_wr_char>
	}
	if(digits>5)
    1180:	c6 30       	cpi	r28, 0x06	; 6
    1182:	d1 05       	cpc	r29, r1
    1184:	1c f0       	brlt	.+6      	; 0x118c <lcd_print+0x110>
	{
		lcd_wr_char('E');
    1186:	85 e4       	ldi	r24, 0x45	; 69
    1188:	0e 94 06 08 	call	0x100c	; 0x100c <lcd_wr_char>
	}
	
}
    118c:	df 91       	pop	r29
    118e:	cf 91       	pop	r28
    1190:	1f 91       	pop	r17
    1192:	0f 91       	pop	r16
    1194:	08 95       	ret

00001196 <buzzer_pin_config>:
 * Logic: DDRC pin 3 is configured as output
 * Example Call: buzzer_pin_config();
 */ 
void buzzer_pin_config(){
	
	DDRC = DDRC | 0x08;
    1196:	3b 9a       	sbi	0x07, 3	; 7
	PORTC = PORTC & 0xF7;	
    1198:	43 98       	cbi	0x08, 3	; 8
}
    119a:	08 95       	ret

0000119c <servo1_pin_config>:
 * Logic:  make PORTB 5 pin output
 * Example Call: servo1_pin_config ();
 */ 
void servo1_pin_config (void)
{
 DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
    119c:	25 9a       	sbi	0x04, 5	; 4
 PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
    119e:	2d 9a       	sbi	0x05, 5	; 5
}
    11a0:	08 95       	ret

000011a2 <servo2_pin_config>:
 * Logic:  make PORTB 6 pin output
 * Example Call: servo2_pin_config ();
 */ 
void servo2_pin_config (void)
{
 DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
    11a2:	26 9a       	sbi	0x04, 6	; 4
 PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
    11a4:	2e 9a       	sbi	0x05, 6	; 5
 DDRL  = DDRL | 0xBF;  //making PORTL 6 pin input
    11a6:	ea e0       	ldi	r30, 0x0A	; 10
    11a8:	f1 e0       	ldi	r31, 0x01	; 1
    11aa:	80 81       	ld	r24, Z
    11ac:	8f 6b       	ori	r24, 0xBF	; 191
    11ae:	80 83       	st	Z, r24
 PORTL = PORTL | 0x40; //PORTL 6 internal pull-up enabled
    11b0:	eb e0       	ldi	r30, 0x0B	; 11
    11b2:	f1 e0       	ldi	r31, 0x01	; 1
    11b4:	80 81       	ld	r24, Z
    11b6:	80 64       	ori	r24, 0x40	; 64
    11b8:	80 83       	st	Z, r24
}
    11ba:	08 95       	ret

000011bc <timer1_init>:
//prescale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// actual value: 52.25Hz 
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
    11bc:	e1 e8       	ldi	r30, 0x81	; 129
    11be:	f0 e0       	ldi	r31, 0x00	; 0
    11c0:	10 82       	st	Z, r1
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
    11c2:	8c ef       	ldi	r24, 0xFC	; 252
    11c4:	80 93 85 00 	sts	0x0085, r24
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
    11c8:	81 e0       	ldi	r24, 0x01	; 1
    11ca:	80 93 84 00 	sts	0x0084, r24
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
    11ce:	93 e0       	ldi	r25, 0x03	; 3
    11d0:	90 93 89 00 	sts	0x0089, r25
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
    11d4:	8f ef       	ldi	r24, 0xFF	; 255
    11d6:	80 93 88 00 	sts	0x0088, r24
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
    11da:	90 93 8b 00 	sts	0x008B, r25
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
    11de:	80 93 8a 00 	sts	0x008A, r24
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
    11e2:	90 93 8d 00 	sts	0x008D, r25
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
    11e6:	80 93 8c 00 	sts	0x008C, r24
 ICR1H  = 0x03;	
    11ea:	90 93 87 00 	sts	0x0087, r25
 ICR1L  = 0xFF;
    11ee:	80 93 86 00 	sts	0x0086, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
    11f2:	8b ea       	ldi	r24, 0xAB	; 171
    11f4:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
    11f8:	10 92 82 00 	sts	0x0082, r1
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
    11fc:	8c e0       	ldi	r24, 0x0C	; 12
    11fe:	80 83       	st	Z, r24
}
    1200:	08 95       	ret

00001202 <servo_1>:
 */ 
void servo_1(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
 OCR1AH = 0x00;
    1202:	10 92 89 00 	sts	0x0089, r1
 * Example Call: servo_1(90);
 */ 
void servo_1(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
    1206:	68 2f       	mov	r22, r24
    1208:	70 e0       	ldi	r23, 0x00	; 0
    120a:	80 e0       	ldi	r24, 0x00	; 0
    120c:	90 e0       	ldi	r25, 0x00	; 0
    120e:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
    1212:	2b e7       	ldi	r18, 0x7B	; 123
    1214:	34 e1       	ldi	r19, 0x14	; 20
    1216:	4e ee       	ldi	r20, 0xEE	; 238
    1218:	5f e3       	ldi	r21, 0x3F	; 63
    121a:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
    121e:	20 e0       	ldi	r18, 0x00	; 0
    1220:	30 e0       	ldi	r19, 0x00	; 0
    1222:	4c e0       	ldi	r20, 0x0C	; 12
    1224:	52 e4       	ldi	r21, 0x42	; 66
    1226:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
 OCR1AH = 0x00;
 OCR1AL = (unsigned char) PositionPanServo;
    122a:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
    122e:	60 93 88 00 	sts	0x0088, r22
}
    1232:	08 95       	ret

00001234 <servo_2>:
 */ 
void servo_2(unsigned char degrees)
{
 float PositionTiltServo = 0;
 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
 OCR1BH = 0x00;
    1234:	10 92 8b 00 	sts	0x008B, r1
 * Example Call: servo_2(90);
 */ 
void servo_2(unsigned char degrees)
{
 float PositionTiltServo = 0;
 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
    1238:	68 2f       	mov	r22, r24
    123a:	70 e0       	ldi	r23, 0x00	; 0
    123c:	80 e0       	ldi	r24, 0x00	; 0
    123e:	90 e0       	ldi	r25, 0x00	; 0
    1240:	0e 94 80 12 	call	0x2500	; 0x2500 <__floatunsisf>
    1244:	2b e7       	ldi	r18, 0x7B	; 123
    1246:	34 e1       	ldi	r19, 0x14	; 20
    1248:	4e ee       	ldi	r20, 0xEE	; 238
    124a:	5f e3       	ldi	r21, 0x3F	; 63
    124c:	0e 94 e7 11 	call	0x23ce	; 0x23ce <__divsf3>
    1250:	20 e0       	ldi	r18, 0x00	; 0
    1252:	30 e0       	ldi	r19, 0x00	; 0
    1254:	4c e0       	ldi	r20, 0x0C	; 12
    1256:	52 e4       	ldi	r21, 0x42	; 66
    1258:	0e 94 7f 11 	call	0x22fe	; 0x22fe <__addsf3>
 OCR1BH = 0x00;
 OCR1BL = (unsigned char) PositionTiltServo;
    125c:	0e 94 54 12 	call	0x24a8	; 0x24a8 <__fixunssfsi>
    1260:	60 93 8a 00 	sts	0x008A, r22
}
    1264:	08 95       	ret

00001266 <place_block>:
 * Logic: Rotate the motor upto 84 degree
 * Example Call: place_block();
 */ 
void place_block()
{
	for (i = 160; i > 84; i--)
    1266:	80 ea       	ldi	r24, 0xA0	; 160
    1268:	80 93 2c 02 	sts	0x022C, r24
	{
		servo_1(i);
    126c:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    1270:	82 e3       	ldi	r24, 0x32	; 50
    1272:	93 eb       	ldi	r25, 0xB3	; 179
    1274:	a2 e0       	ldi	r26, 0x02	; 2
    1276:	81 50       	subi	r24, 0x01	; 1
    1278:	90 40       	sbci	r25, 0x00	; 0
    127a:	a0 40       	sbci	r26, 0x00	; 0
    127c:	e1 f7       	brne	.-8      	; 0x1276 <place_block+0x10>
    127e:	00 c0       	rjmp	.+0      	; 0x1280 <place_block+0x1a>
    1280:	00 c0       	rjmp	.+0      	; 0x1282 <place_block+0x1c>
 * Logic: Rotate the motor upto 84 degree
 * Example Call: place_block();
 */ 
void place_block()
{
	for (i = 160; i > 84; i--)
    1282:	80 91 2c 02 	lds	r24, 0x022C
    1286:	81 50       	subi	r24, 0x01	; 1
    1288:	80 93 2c 02 	sts	0x022C, r24
    128c:	85 35       	cpi	r24, 0x55	; 85
    128e:	70 f7       	brcc	.-36     	; 0x126c <place_block+0x6>
	{
		servo_1(i);
		_delay_ms(60);
	}
	servo_2(100);
    1290:	84 e6       	ldi	r24, 0x64	; 100
    1292:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
    1296:	8f ef       	ldi	r24, 0xFF	; 255
    1298:	9f e7       	ldi	r25, 0x7F	; 127
    129a:	a6 e1       	ldi	r26, 0x16	; 22
    129c:	81 50       	subi	r24, 0x01	; 1
    129e:	90 40       	sbci	r25, 0x00	; 0
    12a0:	a0 40       	sbci	r26, 0x00	; 0
    12a2:	e1 f7       	brne	.-8      	; 0x129c <place_block+0x36>
    12a4:	00 c0       	rjmp	.+0      	; 0x12a6 <place_block+0x40>
    12a6:	00 00       	nop
	_delay_ms(500);
	for (i = 84; i < 130; i++)
    12a8:	84 e5       	ldi	r24, 0x54	; 84
    12aa:	80 93 2c 02 	sts	0x022C, r24
	{
		servo_1(i);
    12ae:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    12b2:	89 e9       	ldi	r24, 0x99	; 153
    12b4:	99 e5       	ldi	r25, 0x59	; 89
    12b6:	a1 e0       	ldi	r26, 0x01	; 1
    12b8:	81 50       	subi	r24, 0x01	; 1
    12ba:	90 40       	sbci	r25, 0x00	; 0
    12bc:	a0 40       	sbci	r26, 0x00	; 0
    12be:	e1 f7       	brne	.-8      	; 0x12b8 <place_block+0x52>
    12c0:	00 00       	nop
		servo_1(i);
		_delay_ms(60);
	}
	servo_2(100);
	_delay_ms(500);
	for (i = 84; i < 130; i++)
    12c2:	80 91 2c 02 	lds	r24, 0x022C
    12c6:	8f 5f       	subi	r24, 0xFF	; 255
    12c8:	80 93 2c 02 	sts	0x022C, r24
    12cc:	82 38       	cpi	r24, 0x82	; 130
    12ce:	78 f3       	brcs	.-34     	; 0x12ae <place_block+0x48>
	{
		servo_1(i);
		_delay_ms(30);
	}
	servo_2(120);
    12d0:	88 e7       	ldi	r24, 0x78	; 120
    12d2:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
}
    12d6:	08 95       	ret

000012d8 <place_to_sort>:
 * Logic: Rotate the motor upto 84 degree
 * Example Call: place_to_sort();
 */ 
void place_to_sort()
{
	for (i = 160; i > 84; i--)
    12d8:	80 ea       	ldi	r24, 0xA0	; 160
    12da:	80 93 2c 02 	sts	0x022C, r24
	{
		servo_1(i);
    12de:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    12e2:	89 e9       	ldi	r24, 0x99	; 153
    12e4:	99 e5       	ldi	r25, 0x59	; 89
    12e6:	a1 e0       	ldi	r26, 0x01	; 1
    12e8:	81 50       	subi	r24, 0x01	; 1
    12ea:	90 40       	sbci	r25, 0x00	; 0
    12ec:	a0 40       	sbci	r26, 0x00	; 0
    12ee:	e1 f7       	brne	.-8      	; 0x12e8 <place_to_sort+0x10>
    12f0:	00 00       	nop
 * Logic: Rotate the motor upto 84 degree
 * Example Call: place_to_sort();
 */ 
void place_to_sort()
{
	for (i = 160; i > 84; i--)
    12f2:	80 91 2c 02 	lds	r24, 0x022C
    12f6:	81 50       	subi	r24, 0x01	; 1
    12f8:	80 93 2c 02 	sts	0x022C, r24
    12fc:	85 35       	cpi	r24, 0x55	; 85
    12fe:	78 f7       	brcc	.-34     	; 0x12de <place_to_sort+0x6>
	{
		servo_1(i);
		_delay_ms(30);
	}
	servo_2(85);
    1300:	85 e5       	ldi	r24, 0x55	; 85
    1302:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
    1306:	8f ef       	ldi	r24, 0xFF	; 255
    1308:	9f e7       	ldi	r25, 0x7F	; 127
    130a:	a6 e1       	ldi	r26, 0x16	; 22
    130c:	81 50       	subi	r24, 0x01	; 1
    130e:	90 40       	sbci	r25, 0x00	; 0
    1310:	a0 40       	sbci	r26, 0x00	; 0
    1312:	e1 f7       	brne	.-8      	; 0x130c <place_to_sort+0x34>
    1314:	00 c0       	rjmp	.+0      	; 0x1316 <place_to_sort+0x3e>
    1316:	00 00       	nop
	_delay_ms(500);
	for (i = 84; i < 130; i++)
    1318:	84 e5       	ldi	r24, 0x54	; 84
    131a:	80 93 2c 02 	sts	0x022C, r24
	{
		servo_1(i);
    131e:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    1322:	89 e9       	ldi	r24, 0x99	; 153
    1324:	99 e5       	ldi	r25, 0x59	; 89
    1326:	a1 e0       	ldi	r26, 0x01	; 1
    1328:	81 50       	subi	r24, 0x01	; 1
    132a:	90 40       	sbci	r25, 0x00	; 0
    132c:	a0 40       	sbci	r26, 0x00	; 0
    132e:	e1 f7       	brne	.-8      	; 0x1328 <place_to_sort+0x50>
    1330:	00 00       	nop
		servo_1(i);
		_delay_ms(30);
	}
	servo_2(85);
	_delay_ms(500);
	for (i = 84; i < 130; i++)
    1332:	80 91 2c 02 	lds	r24, 0x022C
    1336:	8f 5f       	subi	r24, 0xFF	; 255
    1338:	80 93 2c 02 	sts	0x022C, r24
    133c:	82 38       	cpi	r24, 0x82	; 130
    133e:	78 f3       	brcs	.-34     	; 0x131e <place_to_sort+0x46>
	{
		servo_1(i);
		_delay_ms(30);
	}
}
    1340:	08 95       	ret

00001342 <pick_block>:
 * Output : Picks a block 
 * Logic: Rotate the motor upto the required angle 
 * Example Call: pick_block(87);
 */ 
void pick_block(int angle)
{
    1342:	0f 93       	push	r16
    1344:	1f 93       	push	r17
    1346:	cf 93       	push	r28
    1348:	df 93       	push	r29
    134a:	ec 01       	movw	r28, r24
	for (i = 130; i > angle; i--)
    134c:	82 e8       	ldi	r24, 0x82	; 130
    134e:	80 93 2c 02 	sts	0x022C, r24
    1352:	c2 38       	cpi	r28, 0x82	; 130
    1354:	d1 05       	cpc	r29, r1
    1356:	a4 f4       	brge	.+40     	; 0x1380 <pick_block+0x3e>
	{
		servo_1(i);
    1358:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    135c:	89 e9       	ldi	r24, 0x99	; 153
    135e:	99 e5       	ldi	r25, 0x59	; 89
    1360:	a1 e0       	ldi	r26, 0x01	; 1
    1362:	81 50       	subi	r24, 0x01	; 1
    1364:	90 40       	sbci	r25, 0x00	; 0
    1366:	a0 40       	sbci	r26, 0x00	; 0
    1368:	e1 f7       	brne	.-8      	; 0x1362 <pick_block+0x20>
    136a:	00 00       	nop
 * Logic: Rotate the motor upto the required angle 
 * Example Call: pick_block(87);
 */ 
void pick_block(int angle)
{
	for (i = 130; i > angle; i--)
    136c:	80 91 2c 02 	lds	r24, 0x022C
    1370:	81 50       	subi	r24, 0x01	; 1
    1372:	80 93 2c 02 	sts	0x022C, r24
    1376:	28 2f       	mov	r18, r24
    1378:	30 e0       	ldi	r19, 0x00	; 0
    137a:	c2 17       	cp	r28, r18
    137c:	d3 07       	cpc	r29, r19
    137e:	64 f3       	brlt	.-40     	; 0x1358 <pick_block+0x16>
	{
		servo_1(i);
		_delay_ms(30);
	}
	 i=120;
    1380:	88 e7       	ldi	r24, 0x78	; 120
    1382:	80 93 2c 02 	sts	0x022C, r24
	 while(grip_switch == 0x40)
    1386:	80 91 0f 02 	lds	r24, 0x020F
    138a:	80 34       	cpi	r24, 0x40	; 64
    138c:	41 f0       	breq	.+16     	; 0x139e <pick_block+0x5c>
    138e:	1f c0       	rjmp	.+62     	; 0x13ce <pick_block+0x8c>
	 {
		 if (i == 45){
    1390:	80 91 2c 02 	lds	r24, 0x022C
    1394:	8d 32       	cpi	r24, 0x2D	; 45
    1396:	31 f4       	brne	.+12     	; 0x13a4 <pick_block+0x62>
			 buzzer_off();
    1398:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			break;
    139c:	18 c0       	rjmp	.+48     	; 0x13ce <pick_block+0x8c>
		_delay_ms(30);
	}
	 i=120;
	 while(grip_switch == 0x40)
	 {
		 if (i == 45){
    139e:	88 e7       	ldi	r24, 0x78	; 120
			break;
		 }			
		 servo_2(i);
		 _delay_ms(45);
		 i--;
		 grip_switch = PINL;
    13a0:	09 e0       	ldi	r16, 0x09	; 9
    13a2:	11 e0       	ldi	r17, 0x01	; 1
	 {
		 if (i == 45){
			 buzzer_off();
			break;
		 }			
		 servo_2(i);
    13a4:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
    13a8:	86 e6       	ldi	r24, 0x66	; 102
    13aa:	96 e0       	ldi	r25, 0x06	; 6
    13ac:	a2 e0       	ldi	r26, 0x02	; 2
    13ae:	81 50       	subi	r24, 0x01	; 1
    13b0:	90 40       	sbci	r25, 0x00	; 0
    13b2:	a0 40       	sbci	r26, 0x00	; 0
    13b4:	e1 f7       	brne	.-8      	; 0x13ae <pick_block+0x6c>
		 _delay_ms(45);
		 i--;
    13b6:	80 91 2c 02 	lds	r24, 0x022C
    13ba:	81 50       	subi	r24, 0x01	; 1
    13bc:	80 93 2c 02 	sts	0x022C, r24
		 grip_switch = PINL;
    13c0:	d8 01       	movw	r26, r16
    13c2:	8c 91       	ld	r24, X
		 grip_switch = grip_switch & 0x40;
    13c4:	80 74       	andi	r24, 0x40	; 64
    13c6:	80 93 0f 02 	sts	0x020F, r24
	{
		servo_1(i);
		_delay_ms(30);
	}
	 i=120;
	 while(grip_switch == 0x40)
    13ca:	80 34       	cpi	r24, 0x40	; 64
    13cc:	09 f3       	breq	.-62     	; 0x1390 <pick_block+0x4e>
		 i--;
		 grip_switch = PINL;
		 grip_switch = grip_switch & 0x40;
		
	 }
	  buzzer_on();
    13ce:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    13d2:	8c ec       	ldi	r24, 0xCC	; 204
    13d4:	9c ec       	ldi	r25, 0xCC	; 204
    13d6:	a1 e0       	ldi	r26, 0x01	; 1
    13d8:	81 50       	subi	r24, 0x01	; 1
    13da:	90 40       	sbci	r25, 0x00	; 0
    13dc:	a0 40       	sbci	r26, 0x00	; 0
    13de:	e1 f7       	brne	.-8      	; 0x13d8 <pick_block+0x96>
    13e0:	00 c0       	rjmp	.+0      	; 0x13e2 <pick_block+0xa0>
	 _delay_ms(40);
	buzzer_off();
    13e2:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
	for (i = angle; i < 160; i++)
    13e6:	8c 2f       	mov	r24, r28
    13e8:	c0 93 2c 02 	sts	0x022C, r28
    13ec:	c0 3a       	cpi	r28, 0xA0	; 160
    13ee:	90 f4       	brcc	.+36     	; 0x1414 <pick_block+0xd2>
	{
		servo_1(i);
    13f0:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    13f4:	8f ef       	ldi	r24, 0xFF	; 255
    13f6:	9f e1       	ldi	r25, 0x1F	; 31
    13f8:	a1 e0       	ldi	r26, 0x01	; 1
    13fa:	81 50       	subi	r24, 0x01	; 1
    13fc:	90 40       	sbci	r25, 0x00	; 0
    13fe:	a0 40       	sbci	r26, 0x00	; 0
    1400:	e1 f7       	brne	.-8      	; 0x13fa <pick_block+0xb8>
    1402:	00 c0       	rjmp	.+0      	; 0x1404 <pick_block+0xc2>
    1404:	00 00       	nop
		
	 }
	  buzzer_on();
	 _delay_ms(40);
	buzzer_off();
	for (i = angle; i < 160; i++)
    1406:	80 91 2c 02 	lds	r24, 0x022C
    140a:	8f 5f       	subi	r24, 0xFF	; 255
    140c:	80 93 2c 02 	sts	0x022C, r24
    1410:	80 3a       	cpi	r24, 0xA0	; 160
    1412:	70 f3       	brcs	.-36     	; 0x13f0 <pick_block+0xae>
	{
		servo_1(i);
		_delay_ms(25);
	}
}
    1414:	df 91       	pop	r29
    1416:	cf 91       	pop	r28
    1418:	1f 91       	pop	r17
    141a:	0f 91       	pop	r16
    141c:	08 95       	ret

0000141e <pick_at_sort>:
 * Output : Picks a block at sorting area
 * Logic: Rotate the motor 
 * Example Call: pick_at_sort();
 */ 
void pick_at_sort()
{
    141e:	cf 93       	push	r28
    1420:	df 93       	push	r29
	for (i = 130; i > 86; i--)
    1422:	82 e8       	ldi	r24, 0x82	; 130
    1424:	80 93 2c 02 	sts	0x022C, r24
	{
		servo_1(i);
    1428:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    142c:	89 e9       	ldi	r24, 0x99	; 153
    142e:	99 e5       	ldi	r25, 0x59	; 89
    1430:	a1 e0       	ldi	r26, 0x01	; 1
    1432:	81 50       	subi	r24, 0x01	; 1
    1434:	90 40       	sbci	r25, 0x00	; 0
    1436:	a0 40       	sbci	r26, 0x00	; 0
    1438:	e1 f7       	brne	.-8      	; 0x1432 <pick_at_sort+0x14>
    143a:	00 00       	nop
 * Logic: Rotate the motor 
 * Example Call: pick_at_sort();
 */ 
void pick_at_sort()
{
	for (i = 130; i > 86; i--)
    143c:	80 91 2c 02 	lds	r24, 0x022C
    1440:	81 50       	subi	r24, 0x01	; 1
    1442:	80 93 2c 02 	sts	0x022C, r24
    1446:	87 35       	cpi	r24, 0x57	; 87
    1448:	78 f7       	brcc	.-34     	; 0x1428 <pick_at_sort+0xa>
	{
		servo_1(i);
		_delay_ms(30);
	}
	i=90;
    144a:	8a e5       	ldi	r24, 0x5A	; 90
    144c:	80 93 2c 02 	sts	0x022C, r24
	while(grip_switch == 0x40)
    1450:	80 91 0f 02 	lds	r24, 0x020F
    1454:	80 34       	cpi	r24, 0x40	; 64
    1456:	41 f0       	breq	.+16     	; 0x1468 <pick_at_sort+0x4a>
    1458:	41 c0       	rjmp	.+130    	; 0x14dc <pick_at_sort+0xbe>
	{
		if (i == 55){
    145a:	80 91 2c 02 	lds	r24, 0x022C
    145e:	87 33       	cpi	r24, 0x37	; 55
    1460:	31 f4       	brne	.+12     	; 0x146e <pick_at_sort+0x50>
			buzzer_off();
    1462:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			break;
    1466:	17 c0       	rjmp	.+46     	; 0x1496 <pick_at_sort+0x78>
		_delay_ms(30);
	}
	i=90;
	while(grip_switch == 0x40)
	{
		if (i == 55){
    1468:	8a e5       	ldi	r24, 0x5A	; 90
			break;
		}
		servo_2(i);
		_delay_ms(45);
		i--;
		grip_switch = PINL;
    146a:	c9 e0       	ldi	r28, 0x09	; 9
    146c:	d1 e0       	ldi	r29, 0x01	; 1
	{
		if (i == 55){
			buzzer_off();
			break;
		}
		servo_2(i);
    146e:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
    1472:	86 e6       	ldi	r24, 0x66	; 102
    1474:	96 e0       	ldi	r25, 0x06	; 6
    1476:	a2 e0       	ldi	r26, 0x02	; 2
    1478:	81 50       	subi	r24, 0x01	; 1
    147a:	90 40       	sbci	r25, 0x00	; 0
    147c:	a0 40       	sbci	r26, 0x00	; 0
    147e:	e1 f7       	brne	.-8      	; 0x1478 <pick_at_sort+0x5a>
		_delay_ms(45);
		i--;
    1480:	80 91 2c 02 	lds	r24, 0x022C
    1484:	81 50       	subi	r24, 0x01	; 1
    1486:	80 93 2c 02 	sts	0x022C, r24
		grip_switch = PINL;
    148a:	88 81       	ld	r24, Y
		grip_switch = grip_switch & 0x40;
    148c:	80 74       	andi	r24, 0x40	; 64
    148e:	80 93 0f 02 	sts	0x020F, r24
	{
		servo_1(i);
		_delay_ms(30);
	}
	i=90;
	while(grip_switch == 0x40)
    1492:	80 34       	cpi	r24, 0x40	; 64
    1494:	11 f3       	breq	.-60     	; 0x145a <pick_at_sort+0x3c>
		i--;
		grip_switch = PINL;
		grip_switch = grip_switch & 0x40;
		
	}
	buzzer_on();
    1496:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    149a:	8c ec       	ldi	r24, 0xCC	; 204
    149c:	9c ec       	ldi	r25, 0xCC	; 204
    149e:	a1 e0       	ldi	r26, 0x01	; 1
    14a0:	81 50       	subi	r24, 0x01	; 1
    14a2:	90 40       	sbci	r25, 0x00	; 0
    14a4:	a0 40       	sbci	r26, 0x00	; 0
    14a6:	e1 f7       	brne	.-8      	; 0x14a0 <pick_at_sort+0x82>
    14a8:	00 c0       	rjmp	.+0      	; 0x14aa <pick_at_sort+0x8c>
	_delay_ms(40);
	buzzer_off();
    14aa:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
	for (i = 86; i < 160; i++)
    14ae:	86 e5       	ldi	r24, 0x56	; 86
    14b0:	80 93 2c 02 	sts	0x022C, r24
    14b4:	22 c0       	rjmp	.+68     	; 0x14fa <pick_at_sort+0xdc>
	{
		servo_1(i);
    14b6:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    14ba:	8f ef       	ldi	r24, 0xFF	; 255
    14bc:	9f e1       	ldi	r25, 0x1F	; 31
    14be:	a1 e0       	ldi	r26, 0x01	; 1
    14c0:	81 50       	subi	r24, 0x01	; 1
    14c2:	90 40       	sbci	r25, 0x00	; 0
    14c4:	a0 40       	sbci	r26, 0x00	; 0
    14c6:	e1 f7       	brne	.-8      	; 0x14c0 <pick_at_sort+0xa2>
    14c8:	00 c0       	rjmp	.+0      	; 0x14ca <pick_at_sort+0xac>
    14ca:	00 00       	nop
		
	}
	buzzer_on();
	_delay_ms(40);
	buzzer_off();
	for (i = 86; i < 160; i++)
    14cc:	80 91 2c 02 	lds	r24, 0x022C
    14d0:	8f 5f       	subi	r24, 0xFF	; 255
    14d2:	80 93 2c 02 	sts	0x022C, r24
    14d6:	80 3a       	cpi	r24, 0xA0	; 160
    14d8:	70 f3       	brcs	.-36     	; 0x14b6 <pick_at_sort+0x98>
    14da:	11 c0       	rjmp	.+34     	; 0x14fe <pick_at_sort+0xe0>
		i--;
		grip_switch = PINL;
		grip_switch = grip_switch & 0x40;
		
	}
	buzzer_on();
    14dc:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    14e0:	8c ec       	ldi	r24, 0xCC	; 204
    14e2:	9c ec       	ldi	r25, 0xCC	; 204
    14e4:	a1 e0       	ldi	r26, 0x01	; 1
    14e6:	81 50       	subi	r24, 0x01	; 1
    14e8:	90 40       	sbci	r25, 0x00	; 0
    14ea:	a0 40       	sbci	r26, 0x00	; 0
    14ec:	e1 f7       	brne	.-8      	; 0x14e6 <pick_at_sort+0xc8>
    14ee:	00 c0       	rjmp	.+0      	; 0x14f0 <pick_at_sort+0xd2>
	_delay_ms(40);
	buzzer_off();
    14f0:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
	for (i = 86; i < 160; i++)
    14f4:	86 e5       	ldi	r24, 0x56	; 86
    14f6:	80 93 2c 02 	sts	0x022C, r24
		_delay_ms(30);
	}
	i=90;
	while(grip_switch == 0x40)
	{
		if (i == 55){
    14fa:	86 e5       	ldi	r24, 0x56	; 86
    14fc:	dc cf       	rjmp	.-72     	; 0x14b6 <pick_at_sort+0x98>
	for (i = 86; i < 160; i++)
	{
		servo_1(i);
		_delay_ms(25);
	}
}
    14fe:	df 91       	pop	r29
    1500:	cf 91       	pop	r28
    1502:	08 95       	ret

00001504 <drop_weight>:
 * Logic: Rotate the motors 
 * Example Call: drop_weight();
 */ 
void drop_weight()
{
	for (i = 160; i > 115; i--)
    1504:	80 ea       	ldi	r24, 0xA0	; 160
    1506:	80 93 2c 02 	sts	0x022C, r24
	{
		servo_1(i);
    150a:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    150e:	86 e6       	ldi	r24, 0x66	; 102
    1510:	96 e2       	ldi	r25, 0x26	; 38
    1512:	a3 e0       	ldi	r26, 0x03	; 3
    1514:	81 50       	subi	r24, 0x01	; 1
    1516:	90 40       	sbci	r25, 0x00	; 0
    1518:	a0 40       	sbci	r26, 0x00	; 0
    151a:	e1 f7       	brne	.-8      	; 0x1514 <drop_weight+0x10>
 * Logic: Rotate the motors 
 * Example Call: drop_weight();
 */ 
void drop_weight()
{
	for (i = 160; i > 115; i--)
    151c:	80 91 2c 02 	lds	r24, 0x022C
    1520:	81 50       	subi	r24, 0x01	; 1
    1522:	80 93 2c 02 	sts	0x022C, r24
    1526:	84 37       	cpi	r24, 0x74	; 116
    1528:	80 f7       	brcc	.-32     	; 0x150a <drop_weight+0x6>
	{
		servo_1(i);
		_delay_ms(70);
	}
	servo_2(120);
    152a:	88 e7       	ldi	r24, 0x78	; 120
    152c:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
    1530:	8f ef       	ldi	r24, 0xFF	; 255
    1532:	9f e7       	ldi	r25, 0x7F	; 127
    1534:	a4 e0       	ldi	r26, 0x04	; 4
    1536:	81 50       	subi	r24, 0x01	; 1
    1538:	90 40       	sbci	r25, 0x00	; 0
    153a:	a0 40       	sbci	r26, 0x00	; 0
    153c:	e1 f7       	brne	.-8      	; 0x1536 <drop_weight+0x32>
    153e:	00 c0       	rjmp	.+0      	; 0x1540 <drop_weight+0x3c>
    1540:	00 00       	nop
	_delay_ms(100);
	for (i = 108; i < 160; i++)
    1542:	8c e6       	ldi	r24, 0x6C	; 108
    1544:	80 93 2c 02 	sts	0x022C, r24
	{
		servo_1(i);
    1548:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    154c:	89 e9       	ldi	r24, 0x99	; 153
    154e:	99 e5       	ldi	r25, 0x59	; 89
    1550:	a1 e0       	ldi	r26, 0x01	; 1
    1552:	81 50       	subi	r24, 0x01	; 1
    1554:	90 40       	sbci	r25, 0x00	; 0
    1556:	a0 40       	sbci	r26, 0x00	; 0
    1558:	e1 f7       	brne	.-8      	; 0x1552 <drop_weight+0x4e>
    155a:	00 00       	nop
		servo_1(i);
		_delay_ms(70);
	}
	servo_2(120);
	_delay_ms(100);
	for (i = 108; i < 160; i++)
    155c:	80 91 2c 02 	lds	r24, 0x022C
    1560:	8f 5f       	subi	r24, 0xFF	; 255
    1562:	80 93 2c 02 	sts	0x022C, r24
    1566:	80 3a       	cpi	r24, 0xA0	; 160
    1568:	78 f3       	brcs	.-34     	; 0x1548 <drop_weight+0x44>
	{
		servo_1(i);
		_delay_ms(30);
	}
}
    156a:	08 95       	ret

0000156c <node0_0>:
* Example Call: node0_0(0);
*/
int node0_0(int flag)	
{	
	//when flag value is 0 it will take the left turn and move forward
	if (flag==0)					
    156c:	00 97       	sbiw	r24, 0x00	; 0
    156e:	89 f4       	brne	.+34     	; 0x1592 <node0_0+0x26>
	{
		velocity(180,180);
    1570:	84 eb       	ldi	r24, 0xB4	; 180
    1572:	64 eb       	ldi	r22, 0xB4	; 180
    1574:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		backward_mm(20);
    1578:	84 e1       	ldi	r24, 0x14	; 20
    157a:	90 e0       	ldi	r25, 0x00	; 0
    157c:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		left_degrees(88,0);//100/70
    1580:	88 e5       	ldi	r24, 0x58	; 88
    1582:	90 e0       	ldi	r25, 0x00	; 0
    1584:	60 e0       	ldi	r22, 0x00	; 0
    1586:	70 e0       	ldi	r23, 0x00	; 0
    1588:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    158c:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    1590:	08 95       	ret
		//fw_follow_black_line();
		//fw_follow_black_line();
		
	}
	//when flag value is 1 the bot will take the right turn and will move forward by black line following
	else if (flag==1)				//turn right towards sorting zone
    1592:	81 30       	cpi	r24, 0x01	; 1
    1594:	91 05       	cpc	r25, r1
    1596:	f1 f4       	brne	.+60     	; 0x15d4 <node0_0+0x68>
    1598:	8f ef       	ldi	r24, 0xFF	; 255
    159a:	9f e7       	ldi	r25, 0x7F	; 127
    159c:	a4 e0       	ldi	r26, 0x04	; 4
    159e:	81 50       	subi	r24, 0x01	; 1
    15a0:	90 40       	sbci	r25, 0x00	; 0
    15a2:	a0 40       	sbci	r26, 0x00	; 0
    15a4:	e1 f7       	brne	.-8      	; 0x159e <node0_0+0x32>
    15a6:	00 c0       	rjmp	.+0      	; 0x15a8 <node0_0+0x3c>
    15a8:	00 00       	nop
	{
		_delay_ms(100);
		velocity(180,180);
    15aa:	84 eb       	ldi	r24, 0xB4	; 180
    15ac:	64 eb       	ldi	r22, 0xB4	; 180
    15ae:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		forward_mm(50);
    15b2:	82 e3       	ldi	r24, 0x32	; 50
    15b4:	90 e0       	ldi	r25, 0x00	; 0
    15b6:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		right_degrees(88,0);
    15ba:	88 e5       	ldi	r24, 0x58	; 88
    15bc:	90 e0       	ldi	r25, 0x00	; 0
    15be:	60 e0       	ldi	r22, 0x00	; 0
    15c0:	70 e0       	ldi	r23, 0x00	; 0
    15c2:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		backward_mm(40);
    15c6:	88 e2       	ldi	r24, 0x28	; 40
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		fw_follow_black_line();
    15ce:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    15d2:	08 95       	ret
	}
	// when flag value is 2 the bot will take right turn
	else if (flag==2)
    15d4:	82 30       	cpi	r24, 0x02	; 2
    15d6:	91 05       	cpc	r25, r1
    15d8:	39 f4       	brne	.+14     	; 0x15e8 <node0_0+0x7c>
	{
		right_degrees(88,0);
    15da:	88 e5       	ldi	r24, 0x58	; 88
    15dc:	90 e0       	ldi	r25, 0x00	; 0
    15de:	60 e0       	ldi	r22, 0x00	; 0
    15e0:	70 e0       	ldi	r23, 0x00	; 0
    15e2:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
    15e6:	08 95       	ret
	}
	//when flag value is 3 then the bot will take right turn and will pick the uppermost block after balancing the bridge
	else if (flag==3)
    15e8:	83 30       	cpi	r24, 0x03	; 3
    15ea:	91 05       	cpc	r25, r1
    15ec:	09 f5       	brne	.+66     	; 0x1630 <node0_0+0xc4>
	{
		forward_mm(30);
    15ee:	8e e1       	ldi	r24, 0x1E	; 30
    15f0:	90 e0       	ldi	r25, 0x00	; 0
    15f2:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		velocity(180,180);
    15f6:	84 eb       	ldi	r24, 0xB4	; 180
    15f8:	64 eb       	ldi	r22, 0xB4	; 180
    15fa:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		left_degrees(90,0);
    15fe:	8a e5       	ldi	r24, 0x5A	; 90
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	60 e0       	ldi	r22, 0x00	; 0
    1604:	70 e0       	ldi	r23, 0x00	; 0
    1606:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    160a:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		left_degrees(100,0);
    160e:	84 e6       	ldi	r24, 0x64	; 100
    1610:	90 e0       	ldi	r25, 0x00	; 0
    1612:	60 e0       	ldi	r22, 0x00	; 0
    1614:	70 e0       	ldi	r23, 0x00	; 0
    1616:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		pick_block(90);
    161a:	8a e5       	ldi	r24, 0x5A	; 90
    161c:	90 e0       	ldi	r25, 0x00	; 0
    161e:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		right_degrees(88,0);
    1622:	88 e5       	ldi	r24, 0x58	; 88
    1624:	90 e0       	ldi	r25, 0x00	; 0
    1626:	60 e0       	ldi	r22, 0x00	; 0
    1628:	70 e0       	ldi	r23, 0x00	; 0
    162a:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
    162e:	08 95       	ret
	}
	/*when flag value is 4 then the bot will take 180 turn and will pick the uppermost block.This flag will be called when the the bot will not have to 
	balance the bridge*/
	else if(flag == 4)
    1630:	84 30       	cpi	r24, 0x04	; 4
    1632:	91 05       	cpc	r25, r1
    1634:	e1 f5       	brne	.+120    	; 0x16ae <node0_0+0x142>
	{					
		servo_1(130);
    1636:	82 e8       	ldi	r24, 0x82	; 130
    1638:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
		servo_2(120);
    163c:	88 e7       	ldi	r24, 0x78	; 120
    163e:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
    1642:	8f ef       	ldi	r24, 0xFF	; 255
    1644:	9f ef       	ldi	r25, 0xFF	; 255
    1646:	a8 e0       	ldi	r26, 0x08	; 8
    1648:	81 50       	subi	r24, 0x01	; 1
    164a:	90 40       	sbci	r25, 0x00	; 0
    164c:	a0 40       	sbci	r26, 0x00	; 0
    164e:	e1 f7       	brne	.-8      	; 0x1648 <node0_0+0xdc>
    1650:	00 c0       	rjmp	.+0      	; 0x1652 <node0_0+0xe6>
    1652:	00 00       	nop
		_delay_ms(200);
		velocity(180,180);
    1654:	84 eb       	ldi	r24, 0xB4	; 180
    1656:	64 eb       	ldi	r22, 0xB4	; 180
    1658:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		left_degrees(88,0);
    165c:	88 e5       	ldi	r24, 0x58	; 88
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	60 e0       	ldi	r22, 0x00	; 0
    1662:	70 e0       	ldi	r23, 0x00	; 0
    1664:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		backward_mm(40);
    1668:	88 e2       	ldi	r24, 0x28	; 40
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		left_degrees(88,0);
    1670:	88 e5       	ldi	r24, 0x58	; 88
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	60 e0       	ldi	r22, 0x00	; 0
    1676:	70 e0       	ldi	r23, 0x00	; 0
    1678:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		backward_mm(23);
    167c:	87 e1       	ldi	r24, 0x17	; 23
    167e:	90 e0       	ldi	r25, 0x00	; 0
    1680:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		forward_mm(10);
    1684:	8a e0       	ldi	r24, 0x0A	; 10
    1686:	90 e0       	ldi	r25, 0x00	; 0
    1688:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		backward_mm(15);
    168c:	8f e0       	ldi	r24, 0x0F	; 15
    168e:	90 e0       	ldi	r25, 0x00	; 0
    1690:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		pick_block(107);
    1694:	8b e6       	ldi	r24, 0x6B	; 107
    1696:	90 e0       	ldi	r25, 0x00	; 0
    1698:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		forward_mm(15);
    169c:	8f e0       	ldi	r24, 0x0F	; 15
    169e:	90 e0       	ldi	r25, 0x00	; 0
    16a0:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		backward_mm(120);
    16a4:	88 e7       	ldi	r24, 0x78	; 120
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
    16ac:	08 95       	ret
	}
	//when flag value is 5 then the bot will pick the middle block after placing the first block in isolated area
	else if(flag==5)
    16ae:	85 30       	cpi	r24, 0x05	; 5
    16b0:	91 05       	cpc	r25, r1
    16b2:	a9 f4       	brne	.+42     	; 0x16de <node0_0+0x172>
	{	
		forward_mm(50);
    16b4:	82 e3       	ldi	r24, 0x32	; 50
    16b6:	90 e0       	ldi	r25, 0x00	; 0
    16b8:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		pick_block(96);
    16bc:	80 e6       	ldi	r24, 0x60	; 96
    16be:	90 e0       	ldi	r25, 0x00	; 0
    16c0:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		backward_mm(60);
    16c4:	8c e3       	ldi	r24, 0x3C	; 60
    16c6:	90 e0       	ldi	r25, 0x00	; 0
    16c8:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		right_degrees(88,0);
    16cc:	88 e5       	ldi	r24, 0x58	; 88
    16ce:	90 e0       	ldi	r25, 0x00	; 0
    16d0:	60 e0       	ldi	r22, 0x00	; 0
    16d2:	70 e0       	ldi	r23, 0x00	; 0
    16d4:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    16d8:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    16dc:	08 95       	ret
	}
	//when flag value is 6 then the bot will pick the bottom most block after placing the second block in isolated area
	else if(flag==6)
    16de:	86 30       	cpi	r24, 0x06	; 6
    16e0:	91 05       	cpc	r25, r1
    16e2:	11 f5       	brne	.+68     	; 0x1728 <node0_0+0x1bc>
	{	
		servo_2(120);
    16e4:	88 e7       	ldi	r24, 0x78	; 120
    16e6:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
		forward_mm(70);
    16ea:	86 e4       	ldi	r24, 0x46	; 70
    16ec:	90 e0       	ldi	r25, 0x00	; 0
    16ee:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		pick_block(85);
    16f2:	85 e5       	ldi	r24, 0x55	; 85
    16f4:	90 e0       	ldi	r25, 0x00	; 0
    16f6:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		backward_mm(80);
    16fa:	80 e5       	ldi	r24, 0x50	; 80
    16fc:	90 e0       	ldi	r25, 0x00	; 0
    16fe:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		right_degrees(88,0);
    1702:	88 e5       	ldi	r24, 0x58	; 88
    1704:	90 e0       	ldi	r25, 0x00	; 0
    1706:	60 e0       	ldi	r22, 0x00	; 0
    1708:	70 e0       	ldi	r23, 0x00	; 0
    170a:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		backward_mm(50);
    170e:	82 e3       	ldi	r24, 0x32	; 50
    1710:	90 e0       	ldi	r25, 0x00	; 0
    1712:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		right_degrees(88,0);
    1716:	88 e5       	ldi	r24, 0x58	; 88
    1718:	90 e0       	ldi	r25, 0x00	; 0
    171a:	60 e0       	ldi	r22, 0x00	; 0
    171c:	70 e0       	ldi	r23, 0x00	; 0
    171e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    1722:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    1726:	08 95       	ret
	}
	//when flag value is 7 then the bot will pick the topmost block after balancing the bridge in city area
	else if(flag==7)
    1728:	87 30       	cpi	r24, 0x07	; 7
    172a:	91 05       	cpc	r25, r1
    172c:	a9 f4       	brne	.+42     	; 0x1758 <node0_0+0x1ec>
	{	
		forward_mm(50);
    172e:	82 e3       	ldi	r24, 0x32	; 50
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		pick_block(110);
    1736:	8e e6       	ldi	r24, 0x6E	; 110
    1738:	90 e0       	ldi	r25, 0x00	; 0
    173a:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		backward_mm(60);
    173e:	8c e3       	ldi	r24, 0x3C	; 60
    1740:	90 e0       	ldi	r25, 0x00	; 0
    1742:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		right_degrees(88,0);
    1746:	88 e5       	ldi	r24, 0x58	; 88
    1748:	90 e0       	ldi	r25, 0x00	; 0
    174a:	60 e0       	ldi	r22, 0x00	; 0
    174c:	70 e0       	ldi	r23, 0x00	; 0
    174e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    1752:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    1756:	08 95       	ret
	}
	//when flag value is 8 then the bot will take left turn and will follow the black line
	if (flag==8)	
    1758:	88 30       	cpi	r24, 0x08	; 8
    175a:	91 05       	cpc	r25, r1
    175c:	c9 f4       	brne	.+50     	; 0x1790 <node0_0+0x224>
	{
		velocity(180,180);
    175e:	84 eb       	ldi	r24, 0xB4	; 180
    1760:	64 eb       	ldi	r22, 0xB4	; 180
    1762:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		forward_mm(20);
    1766:	84 e1       	ldi	r24, 0x14	; 20
    1768:	90 e0       	ldi	r25, 0x00	; 0
    176a:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		left_degrees(88,0);
    176e:	88 e5       	ldi	r24, 0x58	; 88
    1770:	90 e0       	ldi	r25, 0x00	; 0
    1772:	60 e0       	ldi	r22, 0x00	; 0
    1774:	70 e0       	ldi	r23, 0x00	; 0
    1776:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
    177a:	8f ef       	ldi	r24, 0xFF	; 255
    177c:	9f e3       	ldi	r25, 0x3F	; 63
    177e:	a2 e0       	ldi	r26, 0x02	; 2
    1780:	81 50       	subi	r24, 0x01	; 1
    1782:	90 40       	sbci	r25, 0x00	; 0
    1784:	a0 40       	sbci	r26, 0x00	; 0
    1786:	e1 f7       	brne	.-8      	; 0x1780 <node0_0+0x214>
    1788:	00 c0       	rjmp	.+0      	; 0x178a <node0_0+0x21e>
    178a:	00 00       	nop
		_delay_ms(50);
		fw_follow_black_line();
    178c:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
	}
}
    1790:	08 95       	ret

00001792 <node_m1_0>:
		pid is bit difficult as the bot will take some time to settle down because of the nature of the pid. when flag value is 3 it will follow the straight line.
		when flag value is 4 the bot will move 19cm forward used while balancing the bridge.
* Example Call: node_m1_0(1);
*/
int node_m1_0(int flag)
{
    1792:	cf 93       	push	r28
    1794:	df 93       	push	r29
    1796:	ec 01       	movw	r28, r24
	//when flag value is 0 it will rotate right while coming from node (1,0) carrying weight block and will put the weight block in the weight container 
	if(flag==0)				//turn right and drop weight block
    1798:	00 97       	sbiw	r24, 0x00	; 0
    179a:	e9 f4       	brne	.+58     	; 0x17d6 <node_m1_0+0x44>
	{
		velocity(180,180);
    179c:	84 eb       	ldi	r24, 0xB4	; 180
    179e:	64 eb       	ldi	r22, 0xB4	; 180
    17a0:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		right_degrees(90,0);
    17a4:	8a e5       	ldi	r24, 0x5A	; 90
    17a6:	90 e0       	ldi	r25, 0x00	; 0
    17a8:	60 e0       	ldi	r22, 0x00	; 0
    17aa:	70 e0       	ldi	r23, 0x00	; 0
    17ac:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		backward_mm(20);
    17b0:	84 e1       	ldi	r24, 0x14	; 20
    17b2:	90 e0       	ldi	r25, 0x00	; 0
    17b4:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		drop_weight();
    17b8:	0e 94 82 0a 	call	0x1504	; 0x1504 <drop_weight>
		backward_mm(40);
    17bc:	88 e2       	ldi	r24, 0x28	; 40
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		right_degrees(88,0);
    17c4:	88 e5       	ldi	r24, 0x58	; 88
    17c6:	90 e0       	ldi	r25, 0x00	; 0
    17c8:	60 e0       	ldi	r22, 0x00	; 0
    17ca:	70 e0       	ldi	r23, 0x00	; 0
    17cc:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    17d0:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    17d4:	2a c0       	rjmp	.+84     	; 0x182a <node_m1_0+0x98>
	}
	//when flag value is 1 it will rotate left while coming from node (-2,0) carrying weight block and will put the weight block in the weight container
	if(flag==1)
    17d6:	81 30       	cpi	r24, 0x01	; 1
    17d8:	91 05       	cpc	r25, r1
    17da:	e9 f4       	brne	.+58     	; 0x1816 <node_m1_0+0x84>
	{
		velocity(180,180);
    17dc:	84 eb       	ldi	r24, 0xB4	; 180
    17de:	64 eb       	ldi	r22, 0xB4	; 180
    17e0:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		left_degrees(93,1);
    17e4:	8d e5       	ldi	r24, 0x5D	; 93
    17e6:	90 e0       	ldi	r25, 0x00	; 0
    17e8:	61 e0       	ldi	r22, 0x01	; 1
    17ea:	70 e0       	ldi	r23, 0x00	; 0
    17ec:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		backward_mm(20);
    17f0:	84 e1       	ldi	r24, 0x14	; 20
    17f2:	90 e0       	ldi	r25, 0x00	; 0
    17f4:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		drop_weight();
    17f8:	0e 94 82 0a 	call	0x1504	; 0x1504 <drop_weight>
		backward_mm(40);
    17fc:	88 e2       	ldi	r24, 0x28	; 40
    17fe:	90 e0       	ldi	r25, 0x00	; 0
    1800:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		right_degrees(88,0);
    1804:	88 e5       	ldi	r24, 0x58	; 88
    1806:	90 e0       	ldi	r25, 0x00	; 0
    1808:	60 e0       	ldi	r22, 0x00	; 0
    180a:	70 e0       	ldi	r23, 0x00	; 0
    180c:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    1810:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    1814:	12 c0       	rjmp	.+36     	; 0x183a <node_m1_0+0xa8>
	}
	/*when flag value is 2 it will make the bot to move forward to 19.5 cm. this is hard coded because for short distance the black line following with pid 
	is bit difficult as the bot will take some time to settle down because of the nature of the pid */ 
	if(flag==2)					//go straight
    1816:	82 30       	cpi	r24, 0x02	; 2
    1818:	91 05       	cpc	r25, r1
    181a:	39 f4       	brne	.+14     	; 0x182a <node_m1_0+0x98>
	{
		velocity(200,200);	//150,200
    181c:	88 ec       	ldi	r24, 0xC8	; 200
    181e:	68 ec       	ldi	r22, 0xC8	; 200
    1820:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		//forward_mm(195);
		fw_follow_black_line();
    1824:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    1828:	13 c0       	rjmp	.+38     	; 0x1850 <node_m1_0+0xbe>
	}
	//when flag value is 3 it will follow the straight line
	if(flag==3)
    182a:	c3 30       	cpi	r28, 0x03	; 3
    182c:	d1 05       	cpc	r29, r1
    182e:	29 f4       	brne	.+10     	; 0x183a <node_m1_0+0xa8>
	{   
		fw_follow_black_line();
    1830:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		stop();
    1834:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    1838:	0b c0       	rjmp	.+22     	; 0x1850 <node_m1_0+0xbe>
	}
	//when flag value is 4 the bot will move 19cm forward used while balancing the bridge
	if(flag==4)					//go straight
    183a:	c4 30       	cpi	r28, 0x04	; 4
    183c:	d1 05       	cpc	r29, r1
    183e:	41 f4       	brne	.+16     	; 0x1850 <node_m1_0+0xbe>
	{
		velocity(190,180);
    1840:	8e eb       	ldi	r24, 0xBE	; 190
    1842:	64 eb       	ldi	r22, 0xB4	; 180
    1844:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		forward_mm(190);
    1848:	8e eb       	ldi	r24, 0xBE	; 190
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
	}
}
    1850:	df 91       	pop	r29
    1852:	cf 91       	pop	r28
    1854:	08 95       	ret

00001856 <node_m2_0>:
* Logic:when flag value is 0 it will pick the block from the sorting zone and will start to move the isolated area.when flag is 1 it will place
  the block in sorting zone and it will detect the color and will store the result in variable sortedFlag[]  
* Example Call: node_m2_0(1)
*/
int node_m2_0(int flag)
{
    1856:	cf 93       	push	r28
    1858:	df 93       	push	r29
	//when flag value is 0 it will pick the block from the sorting zone and will start to move the isolated area
	if (flag == 0)
    185a:	00 97       	sbiw	r24, 0x00	; 0
    185c:	89 f4       	brne	.+34     	; 0x1880 <node_m2_0+0x2a>
	{							//pick weight block
		pick_block(90);
    185e:	8a e5       	ldi	r24, 0x5A	; 90
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		right_degrees(185,1);
    1866:	89 eb       	ldi	r24, 0xB9	; 185
    1868:	90 e0       	ldi	r25, 0x00	; 0
    186a:	61 e0       	ldi	r22, 0x01	; 1
    186c:	70 e0       	ldi	r23, 0x00	; 0
    186e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		backward_mm(30);
    1872:	8e e1       	ldi	r24, 0x1E	; 30
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		fw_follow_black_line();
    187a:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    187e:	65 c0       	rjmp	.+202    	; 0x194a <node_m2_0+0xf4>
	} 
	//when flag is 1 it will place the block in sorting zone and it will detect the color and will store the result in variable sortedFlag[]
	else if (flag == 1)
    1880:	81 30       	cpi	r24, 0x01	; 1
    1882:	91 05       	cpc	r25, r1
    1884:	09 f0       	breq	.+2      	; 0x1888 <node_m2_0+0x32>
    1886:	61 c0       	rjmp	.+194    	; 0x194a <node_m2_0+0xf4>
	{											//place block in sorting zone 
		velocity(180,180);
    1888:	84 eb       	ldi	r24, 0xB4	; 180
    188a:	64 eb       	ldi	r22, 0xB4	; 180
    188c:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		right_degrees(88,0);
    1890:	88 e5       	ldi	r24, 0x58	; 88
    1892:	90 e0       	ldi	r25, 0x00	; 0
    1894:	60 e0       	ldi	r22, 0x00	; 0
    1896:	70 e0       	ldi	r23, 0x00	; 0
    1898:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		backward_mm(25);
    189c:	89 e1       	ldi	r24, 0x19	; 25
    189e:	90 e0       	ldi	r25, 0x00	; 0
    18a0:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		place_to_sort();
    18a4:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <place_to_sort>
		forward_mm(150);
    18a8:	86 e9       	ldi	r24, 0x96	; 150
    18aa:	90 e0       	ldi	r25, 0x00	; 0
    18ac:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
    18b0:	8f ef       	ldi	r24, 0xFF	; 255
    18b2:	9f e7       	ldi	r25, 0x7F	; 127
    18b4:	a6 e1       	ldi	r26, 0x16	; 22
    18b6:	81 50       	subi	r24, 0x01	; 1
    18b8:	90 40       	sbci	r25, 0x00	; 0
    18ba:	a0 40       	sbci	r26, 0x00	; 0
    18bc:	e1 f7       	brne	.-8      	; 0x18b6 <node_m2_0+0x60>
    18be:	00 c0       	rjmp	.+0      	; 0x18c0 <node_m2_0+0x6a>
    18c0:	00 00       	nop
		_delay_ms(500);
		sortedFlag[index] = detect_color();
    18c2:	c0 91 24 02 	lds	r28, 0x0224
    18c6:	d0 91 25 02 	lds	r29, 0x0225
    18ca:	0e 94 c9 01 	call	0x392	; 0x392 <detect_color>
    18ce:	26 e2       	ldi	r18, 0x26	; 38
    18d0:	32 e0       	ldi	r19, 0x02	; 2
    18d2:	cc 0f       	add	r28, r28
    18d4:	dd 1f       	adc	r29, r29
    18d6:	c2 0f       	add	r28, r18
    18d8:	d3 1f       	adc	r29, r19
    18da:	99 83       	std	Y+1, r25	; 0x01
    18dc:	88 83       	st	Y, r24
		index++;
    18de:	80 91 24 02 	lds	r24, 0x0224
    18e2:	90 91 25 02 	lds	r25, 0x0225
    18e6:	ac 01       	movw	r20, r24
    18e8:	4f 5f       	subi	r20, 0xFF	; 255
    18ea:	5f 4f       	sbci	r21, 0xFF	; 255
    18ec:	50 93 25 02 	sts	0x0225, r21
    18f0:	40 93 24 02 	sts	0x0224, r20
		print_color(sortedFlag[index - 1]);
    18f4:	88 0f       	add	r24, r24
    18f6:	99 1f       	adc	r25, r25
    18f8:	28 0f       	add	r18, r24
    18fa:	39 1f       	adc	r19, r25
    18fc:	d9 01       	movw	r26, r18
    18fe:	8d 91       	ld	r24, X+
    1900:	9c 91       	ld	r25, X
    1902:	0e 94 84 02 	call	0x508	; 0x508 <print_color>
		velocity(180,180);		//180,165
    1906:	84 eb       	ldi	r24, 0xB4	; 180
    1908:	64 eb       	ldi	r22, 0xB4	; 180
    190a:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		backward_mm(140);
    190e:	8c e8       	ldi	r24, 0x8C	; 140
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		pick_at_sort();
    1916:	0e 94 0f 0a 	call	0x141e	; 0x141e <pick_at_sort>
		backward_mm(50);
    191a:	82 e3       	ldi	r24, 0x32	; 50
    191c:	90 e0       	ldi	r25, 0x00	; 0
    191e:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		right_degrees(90,0);
    1922:	8a e5       	ldi	r24, 0x5A	; 90
    1924:	90 e0       	ldi	r25, 0x00	; 0
    1926:	60 e0       	ldi	r22, 0x00	; 0
    1928:	70 e0       	ldi	r23, 0x00	; 0
    192a:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		velocity(190,220);
    192e:	8e eb       	ldi	r24, 0xBE	; 190
    1930:	6c ed       	ldi	r22, 0xDC	; 220
    1932:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		backward_mm(50);
    1936:	82 e3       	ldi	r24, 0x32	; 50
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		fw_follow_black_line();
    193e:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		velocity(255,255);
    1942:	8f ef       	ldi	r24, 0xFF	; 255
    1944:	6f ef       	ldi	r22, 0xFF	; 255
    1946:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
	}	
}
    194a:	df 91       	pop	r29
    194c:	cf 91       	pop	r28
    194e:	08 95       	ret

00001950 <node_0_1>:
		implementation file. when flag is 1 it will take left turn and will follow the black line.when flag is 2 it will take right turn and will follow the
		black line 
* Example Call: node_0_1(0,1);
*/
int node_0_1(int flag,int valid)
{
    1950:	cf 93       	push	r28
    1952:	df 93       	push	r29
    1954:	ec 01       	movw	r28, r24
	/*when flag is 0 and valid is 1 then this whole flag==0 loop will be executed. Here it will detect the flag color,place if color matches. The valid
	part only works in the first run since we are detecting all the flags in first run and it is controlled by passing different parameters though
	implementation file*/
	if (flag==0)				//detect color at B-flag and place block if color matches 
    1956:	00 97       	sbiw	r24, 0x00	; 0
    1958:	09 f0       	breq	.+2      	; 0x195c <node_0_1+0xc>
    195a:	7e c0       	rjmp	.+252    	; 0x1a58 <node_0_1+0x108>
	{
		if(valid){
    195c:	61 15       	cp	r22, r1
    195e:	71 05       	cpc	r23, r1
    1960:	09 f4       	brne	.+2      	; 0x1964 <node_0_1+0x14>
    1962:	5a c0       	rjmp	.+180    	; 0x1a18 <node_0_1+0xc8>
		forward_mm(190);
    1964:	8e eb       	ldi	r24, 0xBE	; 190
    1966:	90 e0       	ldi	r25, 0x00	; 0
    1968:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
	 	rotate_at_flag();
    196c:	0e 94 ff 06 	call	0xdfe	; 0xdfe <rotate_at_flag>
		b_flag=detect_color();
    1970:	0e 94 c9 01 	call	0x392	; 0x392 <detect_color>
    1974:	90 93 21 02 	sts	0x0221, r25
    1978:	80 93 20 02 	sts	0x0220, r24
		print_color(b_flag);
    197c:	0e 94 84 02 	call	0x508	; 0x508 <print_color>
		backward_mm(50);
    1980:	82 e3       	ldi	r24, 0x32	; 50
    1982:	90 e0       	ldi	r25, 0x00	; 0
    1984:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		stop();
    1988:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    198c:	8f ef       	ldi	r24, 0xFF	; 255
    198e:	9f e7       	ldi	r25, 0x7F	; 127
    1990:	a6 e1       	ldi	r26, 0x16	; 22
    1992:	81 50       	subi	r24, 0x01	; 1
    1994:	90 40       	sbci	r25, 0x00	; 0
    1996:	a0 40       	sbci	r26, 0x00	; 0
    1998:	e1 f7       	brne	.-8      	; 0x1992 <node_0_1+0x42>
    199a:	00 c0       	rjmp	.+0      	; 0x199c <node_0_1+0x4c>
    199c:	00 00       	nop
		_delay_ms(500);
		left_degrees(58,1);//60/62
    199e:	8a e3       	ldi	r24, 0x3A	; 58
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	61 e0       	ldi	r22, 0x01	; 1
    19a4:	70 e0       	ldi	r23, 0x00	; 0
    19a6:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		stop();
    19aa:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    19ae:	8f ef       	ldi	r24, 0xFF	; 255
    19b0:	9f e7       	ldi	r25, 0x7F	; 127
    19b2:	a6 e1       	ldi	r26, 0x16	; 22
    19b4:	81 50       	subi	r24, 0x01	; 1
    19b6:	90 40       	sbci	r25, 0x00	; 0
    19b8:	a0 40       	sbci	r26, 0x00	; 0
    19ba:	e1 f7       	brne	.-8      	; 0x19b4 <node_0_1+0x64>
    19bc:	00 c0       	rjmp	.+0      	; 0x19be <node_0_1+0x6e>
    19be:	00 00       	nop
		_delay_ms(500);
		velocity(255,195);
    19c0:	8f ef       	ldi	r24, 0xFF	; 255
    19c2:	63 ec       	ldi	r22, 0xC3	; 195
    19c4:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		backward_mm(150);//220/160
    19c8:	86 e9       	ldi	r24, 0x96	; 150
    19ca:	90 e0       	ldi	r25, 0x00	; 0
    19cc:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
	
		stop();
    19d0:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    19d4:	8f ef       	ldi	r24, 0xFF	; 255
    19d6:	9f e7       	ldi	r25, 0x7F	; 127
    19d8:	a6 e1       	ldi	r26, 0x16	; 22
    19da:	81 50       	subi	r24, 0x01	; 1
    19dc:	90 40       	sbci	r25, 0x00	; 0
    19de:	a0 40       	sbci	r26, 0x00	; 0
    19e0:	e1 f7       	brne	.-8      	; 0x19da <node_0_1+0x8a>
    19e2:	00 c0       	rjmp	.+0      	; 0x19e4 <node_0_1+0x94>
    19e4:	00 00       	nop
		_delay_ms(500);
		soft_right_2();
    19e6:	0e 94 f6 02 	call	0x5ec	; 0x5ec <soft_right_2>
    19ea:	89 e9       	ldi	r24, 0x99	; 153
    19ec:	99 e5       	ldi	r25, 0x59	; 89
    19ee:	ac e1       	ldi	r26, 0x1C	; 28
    19f0:	81 50       	subi	r24, 0x01	; 1
    19f2:	90 40       	sbci	r25, 0x00	; 0
    19f4:	a0 40       	sbci	r26, 0x00	; 0
    19f6:	e1 f7       	brne	.-8      	; 0x19f0 <node_0_1+0xa0>
    19f8:	00 00       	nop
		_delay_ms(630);
		velocity(180,180);
    19fa:	84 eb       	ldi	r24, 0xB4	; 180
    19fc:	64 eb       	ldi	r22, 0xB4	; 180
    19fe:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		stop();
    1a02:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    1a06:	8f ef       	ldi	r24, 0xFF	; 255
    1a08:	9f ef       	ldi	r25, 0xFF	; 255
    1a0a:	a9 e5       	ldi	r26, 0x59	; 89
    1a0c:	81 50       	subi	r24, 0x01	; 1
    1a0e:	90 40       	sbci	r25, 0x00	; 0
    1a10:	a0 40       	sbci	r26, 0x00	; 0
    1a12:	e1 f7       	brne	.-8      	; 0x1a0c <node_0_1+0xbc>
    1a14:	00 c0       	rjmp	.+0      	; 0x1a16 <node_0_1+0xc6>
    1a16:	00 00       	nop
		_delay_ms(2000);
		}		
		if (b_flag==sortedFlag[index-1])		//place block and go over bridge
    1a18:	e0 91 24 02 	lds	r30, 0x0224
    1a1c:	f0 91 25 02 	lds	r31, 0x0225
    1a20:	ee 0f       	add	r30, r30
    1a22:	ff 1f       	adc	r31, r31
    1a24:	ec 5d       	subi	r30, 0xDC	; 220
    1a26:	fd 4f       	sbci	r31, 0xFD	; 253
    1a28:	20 81       	ld	r18, Z
    1a2a:	31 81       	ldd	r19, Z+1	; 0x01
    1a2c:	80 91 20 02 	lds	r24, 0x0220
    1a30:	90 91 21 02 	lds	r25, 0x0221
    1a34:	28 17       	cp	r18, r24
    1a36:	39 07       	cpc	r19, r25
    1a38:	79 f4       	brne	.+30     	; 0x1a58 <node_0_1+0x108>
		{
			buzzer_on();
    1a3a:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    1a3e:	8f ef       	ldi	r24, 0xFF	; 255
    1a40:	9f ef       	ldi	r25, 0xFF	; 255
    1a42:	a8 e0       	ldi	r26, 0x08	; 8
    1a44:	81 50       	subi	r24, 0x01	; 1
    1a46:	90 40       	sbci	r25, 0x00	; 0
    1a48:	a0 40       	sbci	r26, 0x00	; 0
    1a4a:	e1 f7       	brne	.-8      	; 0x1a44 <node_0_1+0xf4>
    1a4c:	00 c0       	rjmp	.+0      	; 0x1a4e <node_0_1+0xfe>
    1a4e:	00 00       	nop
			_delay_ms(200);
			buzzer_off();
    1a50:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			place_block();
    1a54:	0e 94 33 09 	call	0x1266	; 0x1266 <place_block>
			
		}
		
	}
	//when flag is 1 it will take left turn and will follow the black line
	if (flag==1)			//turn left 
    1a58:	c1 30       	cpi	r28, 0x01	; 1
    1a5a:	d1 05       	cpc	r29, r1
    1a5c:	69 f4       	brne	.+26     	; 0x1a78 <node_0_1+0x128>
	{
		//left();
		//_delay_ms(1);
		backward_mm(20);
    1a5e:	84 e1       	ldi	r24, 0x14	; 20
    1a60:	90 e0       	ldi	r25, 0x00	; 0
    1a62:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		left_degrees(88,0);
    1a66:	88 e5       	ldi	r24, 0x58	; 88
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	60 e0       	ldi	r22, 0x00	; 0
    1a6c:	70 e0       	ldi	r23, 0x00	; 0
    1a6e:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    1a72:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    1a76:	0b c0       	rjmp	.+22     	; 0x1a8e <node_0_1+0x13e>
	}
	//when flag is 2 it will take right turn and will follow the black line
	if (flag==2)			//turn right 
    1a78:	c2 30       	cpi	r28, 0x02	; 2
    1a7a:	d1 05       	cpc	r29, r1
    1a7c:	41 f4       	brne	.+16     	; 0x1a8e <node_0_1+0x13e>
	{
		right_degrees(67,1);
    1a7e:	83 e4       	ldi	r24, 0x43	; 67
    1a80:	90 e0       	ldi	r25, 0x00	; 0
    1a82:	61 e0       	ldi	r22, 0x01	; 1
    1a84:	70 e0       	ldi	r23, 0x00	; 0
    1a86:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    1a8a:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
	}
}
    1a8e:	df 91       	pop	r29
    1a90:	cf 91       	pop	r28
    1a92:	08 95       	ret

00001a94 <node_m1_1>:
		part only works in the first run since we are detecting all the flags in first run and it is controlled by passing different parameters though
		implementation file. when flag is 1 it is used to take right angle and to follow the black line.
* Example Call: node_m1_1(0,1)
*/
void node_m1_1(int flag,int valid) 
{
    1a94:	cf 93       	push	r28
    1a96:	df 93       	push	r29
    1a98:	eb 01       	movw	r28, r22
	/*when flag is 0 and valid is 1 then this whole flag==0 loop will be executed. Here it will detect the flag color,place if color matches. The valid 
	part only works in the first run since we are detecting all the flags in first run and it is controlled by passing different parameters though
	 implementation file*/ 
	if (flag == 0) 
    1a9a:	00 97       	sbiw	r24, 0x00	; 0
    1a9c:	09 f0       	breq	.+2      	; 0x1aa0 <node_m1_1+0xc>
    1a9e:	c7 c0       	rjmp	.+398    	; 0x1c2e <node_m1_1+0x19a>
	{								
		right_degrees(93,0);
    1aa0:	8d e5       	ldi	r24, 0x5D	; 93
    1aa2:	90 e0       	ldi	r25, 0x00	; 0
    1aa4:	60 e0       	ldi	r22, 0x00	; 0
    1aa6:	70 e0       	ldi	r23, 0x00	; 0
    1aa8:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
	
		if(valid)		//the bot will move from B flag to C flag
    1aac:	20 97       	sbiw	r28, 0x00	; 0
    1aae:	09 f4       	brne	.+2      	; 0x1ab2 <node_m1_1+0x1e>
    1ab0:	5f c0       	rjmp	.+190    	; 0x1b70 <node_m1_1+0xdc>
		{
			forward_mm(115);
    1ab2:	83 e7       	ldi	r24, 0x73	; 115
    1ab4:	90 e0       	ldi	r25, 0x00	; 0
    1ab6:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
			rotate_at_flag();
    1aba:	0e 94 ff 06 	call	0xdfe	; 0xdfe <rotate_at_flag>
			backward_mm(10);
    1abe:	8a e0       	ldi	r24, 0x0A	; 10
    1ac0:	90 e0       	ldi	r25, 0x00	; 0
    1ac2:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
			c_flag = detect_color();
    1ac6:	0e 94 c9 01 	call	0x392	; 0x392 <detect_color>
    1aca:	90 93 1f 02 	sts	0x021F, r25
    1ace:	80 93 1e 02 	sts	0x021E, r24
			print_color(c_flag);
    1ad2:	0e 94 84 02 	call	0x508	; 0x508 <print_color>
			backward_mm(50);
    1ad6:	82 e3       	ldi	r24, 0x32	; 50
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
			stop();
    1ade:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    1ae2:	8f ef       	ldi	r24, 0xFF	; 255
    1ae4:	9f e7       	ldi	r25, 0x7F	; 127
    1ae6:	a6 e1       	ldi	r26, 0x16	; 22
    1ae8:	81 50       	subi	r24, 0x01	; 1
    1aea:	90 40       	sbci	r25, 0x00	; 0
    1aec:	a0 40       	sbci	r26, 0x00	; 0
    1aee:	e1 f7       	brne	.-8      	; 0x1ae8 <node_m1_1+0x54>
    1af0:	00 c0       	rjmp	.+0      	; 0x1af2 <node_m1_1+0x5e>
    1af2:	00 00       	nop
			_delay_ms(500);
			left_degrees(60,1);
    1af4:	8c e3       	ldi	r24, 0x3C	; 60
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	61 e0       	ldi	r22, 0x01	; 1
    1afa:	70 e0       	ldi	r23, 0x00	; 0
    1afc:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
			stop();
    1b00:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    1b04:	8f ef       	ldi	r24, 0xFF	; 255
    1b06:	9f e7       	ldi	r25, 0x7F	; 127
    1b08:	a6 e1       	ldi	r26, 0x16	; 22
    1b0a:	81 50       	subi	r24, 0x01	; 1
    1b0c:	90 40       	sbci	r25, 0x00	; 0
    1b0e:	a0 40       	sbci	r26, 0x00	; 0
    1b10:	e1 f7       	brne	.-8      	; 0x1b0a <node_m1_1+0x76>
    1b12:	00 c0       	rjmp	.+0      	; 0x1b14 <node_m1_1+0x80>
    1b14:	00 00       	nop
			_delay_ms(500);
			velocity(255,195);
    1b16:	8f ef       	ldi	r24, 0xFF	; 255
    1b18:	63 ec       	ldi	r22, 0xC3	; 195
    1b1a:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
			backward_mm(150);//170
    1b1e:	86 e9       	ldi	r24, 0x96	; 150
    1b20:	90 e0       	ldi	r25, 0x00	; 0
    1b22:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
	
			stop();
    1b26:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    1b2a:	8f ef       	ldi	r24, 0xFF	; 255
    1b2c:	9f e7       	ldi	r25, 0x7F	; 127
    1b2e:	a6 e1       	ldi	r26, 0x16	; 22
    1b30:	81 50       	subi	r24, 0x01	; 1
    1b32:	90 40       	sbci	r25, 0x00	; 0
    1b34:	a0 40       	sbci	r26, 0x00	; 0
    1b36:	e1 f7       	brne	.-8      	; 0x1b30 <node_m1_1+0x9c>
    1b38:	00 c0       	rjmp	.+0      	; 0x1b3a <node_m1_1+0xa6>
    1b3a:	00 00       	nop
			_delay_ms(500);
			soft_right_2();
    1b3c:	0e 94 f6 02 	call	0x5ec	; 0x5ec <soft_right_2>
    1b40:	8f ef       	ldi	r24, 0xFF	; 255
    1b42:	9f eb       	ldi	r25, 0xBF	; 191
    1b44:	a8 e1       	ldi	r26, 0x18	; 24
    1b46:	81 50       	subi	r24, 0x01	; 1
    1b48:	90 40       	sbci	r25, 0x00	; 0
    1b4a:	a0 40       	sbci	r26, 0x00	; 0
    1b4c:	e1 f7       	brne	.-8      	; 0x1b46 <node_m1_1+0xb2>
    1b4e:	00 c0       	rjmp	.+0      	; 0x1b50 <node_m1_1+0xbc>
    1b50:	00 00       	nop
			_delay_ms(550);
			velocity(180,180);
    1b52:	84 eb       	ldi	r24, 0xB4	; 180
    1b54:	64 eb       	ldi	r22, 0xB4	; 180
    1b56:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
			stop();
    1b5a:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    1b5e:	8f ef       	ldi	r24, 0xFF	; 255
    1b60:	9f ef       	ldi	r25, 0xFF	; 255
    1b62:	a9 e5       	ldi	r26, 0x59	; 89
    1b64:	81 50       	subi	r24, 0x01	; 1
    1b66:	90 40       	sbci	r25, 0x00	; 0
    1b68:	a0 40       	sbci	r26, 0x00	; 0
    1b6a:	e1 f7       	brne	.-8      	; 0x1b64 <node_m1_1+0xd0>
    1b6c:	00 c0       	rjmp	.+0      	; 0x1b6e <node_m1_1+0xda>
    1b6e:	00 00       	nop
			_delay_ms(2000);
		}	
		if (c_flag == sortedFlag[index-1])		//if sorted flag is same as the waste then the waste block then the waste block is placed  
    1b70:	e0 91 24 02 	lds	r30, 0x0224
    1b74:	f0 91 25 02 	lds	r31, 0x0225
    1b78:	ee 0f       	add	r30, r30
    1b7a:	ff 1f       	adc	r31, r31
    1b7c:	ec 5d       	subi	r30, 0xDC	; 220
    1b7e:	fd 4f       	sbci	r31, 0xFD	; 253
    1b80:	20 81       	ld	r18, Z
    1b82:	31 81       	ldd	r19, Z+1	; 0x01
    1b84:	80 91 1e 02 	lds	r24, 0x021E
    1b88:	90 91 1f 02 	lds	r25, 0x021F
    1b8c:	28 17       	cp	r18, r24
    1b8e:	39 07       	cpc	r19, r25
    1b90:	e9 f4       	brne	.+58     	; 0x1bcc <node_m1_1+0x138>
		{
			forward_mm(15);
    1b92:	8f e0       	ldi	r24, 0x0F	; 15
    1b94:	90 e0       	ldi	r25, 0x00	; 0
    1b96:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
			place_block();
    1b9a:	0e 94 33 09 	call	0x1266	; 0x1266 <place_block>
			backward_mm(35);
    1b9e:	83 e2       	ldi	r24, 0x23	; 35
    1ba0:	90 e0       	ldi	r25, 0x00	; 0
    1ba2:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
			velocity(150,150);
    1ba6:	86 e9       	ldi	r24, 0x96	; 150
    1ba8:	66 e9       	ldi	r22, 0x96	; 150
    1baa:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
			right_degrees(100,0);
    1bae:	84 e6       	ldi	r24, 0x64	; 100
    1bb0:	90 e0       	ldi	r25, 0x00	; 0
    1bb2:	60 e0       	ldi	r22, 0x00	; 0
    1bb4:	70 e0       	ldi	r23, 0x00	; 0
    1bb6:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
			fw_follow_black_line();
    1bba:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
			node_0_1(2,0);
    1bbe:	82 e0       	ldi	r24, 0x02	; 2
    1bc0:	90 e0       	ldi	r25, 0x00	; 0
    1bc2:	60 e0       	ldi	r22, 0x00	; 0
    1bc4:	70 e0       	ldi	r23, 0x00	; 0
    1bc6:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
    1bca:	3c c0       	rjmp	.+120    	; 0x1c44 <node_m1_1+0x1b0>
		
		}
	else
	{										//if above condition is not satisfied than waste block is taken towards A flag and will be placed over there 
		backward_mm(35);//20
    1bcc:	83 e2       	ldi	r24, 0x23	; 35
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		right_degrees(100,0);
    1bd4:	84 e6       	ldi	r24, 0x64	; 100
    1bd6:	90 e0       	ldi	r25, 0x00	; 0
    1bd8:	60 e0       	ldi	r22, 0x00	; 0
    1bda:	70 e0       	ldi	r23, 0x00	; 0
    1bdc:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		velocity(150,150);
    1be0:	86 e9       	ldi	r24, 0x96	; 150
    1be2:	66 e9       	ldi	r22, 0x96	; 150
    1be4:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		fw_follow_black_line();
    1be8:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		fw_follow_black_line();
    1bec:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		fw_follow_black_line();
    1bf0:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		left_degrees(88,0);
    1bf4:	88 e5       	ldi	r24, 0x58	; 88
    1bf6:	90 e0       	ldi	r25, 0x00	; 0
    1bf8:	60 e0       	ldi	r22, 0x00	; 0
    1bfa:	70 e0       	ldi	r23, 0x00	; 0
    1bfc:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		backward_mm(20);
    1c00:	84 e1       	ldi	r24, 0x14	; 20
    1c02:	90 e0       	ldi	r25, 0x00	; 0
    1c04:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		place_block();
    1c08:	0e 94 33 09 	call	0x1266	; 0x1266 <place_block>
		left_degrees(88,0);
    1c0c:	88 e5       	ldi	r24, 0x58	; 88
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	60 e0       	ldi	r22, 0x00	; 0
    1c12:	70 e0       	ldi	r23, 0x00	; 0
    1c14:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    1c18:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		fw_follow_black_line();
    1c1c:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		left_degrees(95,1);
    1c20:	8f e5       	ldi	r24, 0x5F	; 95
    1c22:	90 e0       	ldi	r25, 0x00	; 0
    1c24:	61 e0       	ldi	r22, 0x01	; 1
    1c26:	70 e0       	ldi	r23, 0x00	; 0
    1c28:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
    1c2c:	0b c0       	rjmp	.+22     	; 0x1c44 <node_m1_1+0x1b0>
	}
} 
//when flag is 1 it is used to take right angle and to follow the black line 
else if (flag == 1)
    1c2e:	81 30       	cpi	r24, 0x01	; 1
    1c30:	91 05       	cpc	r25, r1
    1c32:	41 f4       	brne	.+16     	; 0x1c44 <node_m1_1+0x1b0>
	{									//pick weight block
		right_degrees(200,0);
    1c34:	88 ec       	ldi	r24, 0xC8	; 200
    1c36:	90 e0       	ldi	r25, 0x00	; 0
    1c38:	60 e0       	ldi	r22, 0x00	; 0
    1c3a:	70 e0       	ldi	r23, 0x00	; 0
    1c3c:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    1c40:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
	}
}
    1c44:	df 91       	pop	r29
    1c46:	cf 91       	pop	r28
    1c48:	08 95       	ret

00001c4a <node_1_1>:
* Example Call: node_1_1(0);
*/
int node_1_1(int flag)
{
	//when flag is 0 it will turn right carrying the weight block from the node(-1,1) and will put the weight block in weight block in weight container
	if(flag==0)				//turn right and drop weight
    1c4a:	00 97       	sbiw	r24, 0x00	; 0
    1c4c:	d9 f4       	brne	.+54     	; 0x1c84 <node_1_1+0x3a>
	{
		velocity(180,180);
    1c4e:	84 eb       	ldi	r24, 0xB4	; 180
    1c50:	64 eb       	ldi	r22, 0xB4	; 180
    1c52:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		right_degrees(100,0);
    1c56:	84 e6       	ldi	r24, 0x64	; 100
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	60 e0       	ldi	r22, 0x00	; 0
    1c5c:	70 e0       	ldi	r23, 0x00	; 0
    1c5e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		backward_mm(50);
    1c62:	82 e3       	ldi	r24, 0x32	; 50
    1c64:	90 e0       	ldi	r25, 0x00	; 0
    1c66:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		drop_weight();
    1c6a:	0e 94 82 0a 	call	0x1504	; 0x1504 <drop_weight>
		left_degrees(100,0);
    1c6e:	84 e6       	ldi	r24, 0x64	; 100
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	60 e0       	ldi	r22, 0x00	; 0
    1c74:	70 e0       	ldi	r23, 0x00	; 0
    1c76:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    1c7a:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		stop();
    1c7e:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    1c82:	08 95       	ret
	}
	//when flag is 1 it will turn left carrying the weight block from the node(2,1) and will put the weight block in weight block in weight container
	if(flag==1)
    1c84:	81 30       	cpi	r24, 0x01	; 1
    1c86:	91 05       	cpc	r25, r1
    1c88:	c9 f4       	brne	.+50     	; 0x1cbc <node_1_1+0x72>
	{
		velocity(180,180);
    1c8a:	84 eb       	ldi	r24, 0xB4	; 180
    1c8c:	64 eb       	ldi	r22, 0xB4	; 180
    1c8e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		left_degrees(100,0);
    1c92:	84 e6       	ldi	r24, 0x64	; 100
    1c94:	90 e0       	ldi	r25, 0x00	; 0
    1c96:	60 e0       	ldi	r22, 0x00	; 0
    1c98:	70 e0       	ldi	r23, 0x00	; 0
    1c9a:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		backward_mm(50);
    1c9e:	82 e3       	ldi	r24, 0x32	; 50
    1ca0:	90 e0       	ldi	r25, 0x00	; 0
    1ca2:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		drop_weight();
    1ca6:	0e 94 82 0a 	call	0x1504	; 0x1504 <drop_weight>
		right_degrees(100,0);
    1caa:	84 e6       	ldi	r24, 0x64	; 100
    1cac:	90 e0       	ldi	r25, 0x00	; 0
    1cae:	60 e0       	ldi	r22, 0x00	; 0
    1cb0:	70 e0       	ldi	r23, 0x00	; 0
    1cb2:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		stop();
    1cb6:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <stop>
    1cba:	08 95       	ret
	}
	//when flag is 2 it will follow the black line
	if(flag==2)					//go straight
    1cbc:	82 30       	cpi	r24, 0x02	; 2
    1cbe:	91 05       	cpc	r25, r1
    1cc0:	11 f4       	brne	.+4      	; 0x1cc6 <node_1_1+0x7c>
	{
		fw_follow_black_line();
    1cc2:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
	}
}
    1cc6:	08 95       	ret

00001cc8 <node_2_1>:
* Example Call: node_2_1(1);
*/
void node_2_1(int flag)
{
	//when flag is 0 it will it will place the sorted weight block at node (2,1) 
	if(flag==0)						//turn left and place
    1cc8:	00 97       	sbiw	r24, 0x00	; 0
    1cca:	a1 f4       	brne	.+40     	; 0x1cf4 <node_2_1+0x2c>
	{
		velocity(180,180);
    1ccc:	84 eb       	ldi	r24, 0xB4	; 180
    1cce:	64 eb       	ldi	r22, 0xB4	; 180
    1cd0:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		left_degrees(128,0);
    1cd4:	80 e8       	ldi	r24, 0x80	; 128
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	60 e0       	ldi	r22, 0x00	; 0
    1cda:	70 e0       	ldi	r23, 0x00	; 0
    1cdc:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		backward_mm(50);
    1ce0:	82 e3       	ldi	r24, 0x32	; 50
    1ce2:	90 e0       	ldi	r25, 0x00	; 0
    1ce4:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		place_block();
    1ce8:	0e 94 33 09 	call	0x1266	; 0x1266 <place_block>
		velocity(180,225);
    1cec:	84 eb       	ldi	r24, 0xB4	; 180
    1cee:	61 ee       	ldi	r22, 0xE1	; 225
    1cf0:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
    1cf4:	08 95       	ret

00001cf6 <balanceBridge>:
		 will balance the bridge in IA and again it will carry one weight from IA to the CA since we have one less weight block in CA and it
		 will put that in weight container of CA.when flag value is 4 will take two weight blocks from node(-2,0) and will balance the bridge in CA 
* Example Call: balanceBridge(0);
*/
void balanceBridge(int flag)
{
    1cf6:	cf 93       	push	r28
    1cf8:	df 93       	push	r29
    1cfa:	ec 01       	movw	r28, r24
	//when flag value is 0 it will take one weight block from node(-2,0) and will balance the bridge in CA during the first run
	if (flag==0)
    1cfc:	00 97       	sbiw	r24, 0x00	; 0
    1cfe:	71 f5       	brne	.+92     	; 0x1d5c <balanceBridge+0x66>
	{
		servo_1(130);		//Initializes the arm
    1d00:	82 e8       	ldi	r24, 0x82	; 130
    1d02:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
		servo_2(120);
    1d06:	88 e7       	ldi	r24, 0x78	; 120
    1d08:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
    1d0c:	8f ef       	ldi	r24, 0xFF	; 255
    1d0e:	9f ef       	ldi	r25, 0xFF	; 255
    1d10:	ac e2       	ldi	r26, 0x2C	; 44
    1d12:	81 50       	subi	r24, 0x01	; 1
    1d14:	90 40       	sbci	r25, 0x00	; 0
    1d16:	a0 40       	sbci	r26, 0x00	; 0
    1d18:	e1 f7       	brne	.-8      	; 0x1d12 <balanceBridge+0x1c>
    1d1a:	00 c0       	rjmp	.+0      	; 0x1d1c <balanceBridge+0x26>
    1d1c:	00 00       	nop
		_delay_ms(1000);
		node0_0(8);
    1d1e:	88 e0       	ldi	r24, 0x08	; 8
    1d20:	90 e0       	ldi	r25, 0x00	; 0
    1d22:	0e 94 b6 0a 	call	0x156c	; 0x156c <node0_0>
		node_m1_0(4);
    1d26:	84 e0       	ldi	r24, 0x04	; 4
    1d28:	90 e0       	ldi	r25, 0x00	; 0
    1d2a:	0e 94 c9 0b 	call	0x1792	; 0x1792 <node_m1_0>
		backward_mm(35);
    1d2e:	83 e2       	ldi	r24, 0x23	; 35
    1d30:	90 e0       	ldi	r25, 0x00	; 0
    1d32:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		node_m2_0(0);
    1d36:	80 e0       	ldi	r24, 0x00	; 0
    1d38:	90 e0       	ldi	r25, 0x00	; 0
    1d3a:	0e 94 2b 0c 	call	0x1856	; 0x1856 <node_m2_0>
		node_m1_0(1);
    1d3e:	81 e0       	ldi	r24, 0x01	; 1
    1d40:	90 e0       	ldi	r25, 0x00	; 0
    1d42:	0e 94 c9 0b 	call	0x1792	; 0x1792 <node_m1_0>
		node0_0(2);
    1d46:	82 e0       	ldi	r24, 0x02	; 2
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	0e 94 b6 0a 	call	0x156c	; 0x156c <node0_0>
		backward_mm(60);
    1d4e:	8c e3       	ldi	r24, 0x3C	; 60
    1d50:	90 e0       	ldi	r25, 0x00	; 0
    1d52:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		fw_follow_black_line();
    1d56:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    1d5a:	ca c0       	rjmp	.+404    	; 0x1ef0 <balanceBridge+0x1fa>
	}
	
	//when flag value is 1 will take two weight blocks from node(2,1) and will balance the bridge in IA
	if (flag==1)
    1d5c:	81 30       	cpi	r24, 0x01	; 1
    1d5e:	91 05       	cpc	r25, r1
    1d60:	09 f0       	breq	.+2      	; 0x1d64 <balanceBridge+0x6e>
    1d62:	8a c0       	rjmp	.+276    	; 0x1e78 <balanceBridge+0x182>
	{
		servo_1(150);
    1d64:	86 e9       	ldi	r24, 0x96	; 150
    1d66:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
		servo_2(120);
    1d6a:	88 e7       	ldi	r24, 0x78	; 120
    1d6c:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
    1d70:	8f ef       	ldi	r24, 0xFF	; 255
    1d72:	9f ef       	ldi	r25, 0xFF	; 255
    1d74:	ac e2       	ldi	r26, 0x2C	; 44
    1d76:	81 50       	subi	r24, 0x01	; 1
    1d78:	90 40       	sbci	r25, 0x00	; 0
    1d7a:	a0 40       	sbci	r26, 0x00	; 0
    1d7c:	e1 f7       	brne	.-8      	; 0x1d76 <balanceBridge+0x80>
    1d7e:	00 c0       	rjmp	.+0      	; 0x1d80 <balanceBridge+0x8a>
    1d80:	00 00       	nop
		_delay_ms(1000);
		forward_mm(30);
    1d82:	8e e1       	ldi	r24, 0x1E	; 30
    1d84:	90 e0       	ldi	r25, 0x00	; 0
    1d86:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		velocity(180,180);
    1d8a:	84 eb       	ldi	r24, 0xB4	; 180
    1d8c:	64 eb       	ldi	r22, 0xB4	; 180
    1d8e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		left_degrees(90,0);
    1d92:	8a e5       	ldi	r24, 0x5A	; 90
    1d94:	90 e0       	ldi	r25, 0x00	; 0
    1d96:	60 e0       	ldi	r22, 0x00	; 0
    1d98:	70 e0       	ldi	r23, 0x00	; 0
    1d9a:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		backward_mm(20);
    1d9e:	84 e1       	ldi	r24, 0x14	; 20
    1da0:	90 e0       	ldi	r25, 0x00	; 0
    1da2:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		
		
		fw_follow_black_line();
    1da6:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		fw_follow_black_line();
    1daa:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		backward_mm(30);
    1dae:	8e e1       	ldi	r24, 0x1E	; 30
    1db0:	90 e0       	ldi	r25, 0x00	; 0
    1db2:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		pick_block(88);
    1db6:	88 e5       	ldi	r24, 0x58	; 88
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		velocity(180,180);
    1dbe:	84 eb       	ldi	r24, 0xB4	; 180
    1dc0:	64 eb       	ldi	r22, 0xB4	; 180
    1dc2:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		forward_mm(30);
    1dc6:	8e e1       	ldi	r24, 0x1E	; 30
    1dc8:	90 e0       	ldi	r25, 0x00	; 0
    1dca:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		right_degrees(190,0);
    1dce:	8e eb       	ldi	r24, 0xBE	; 190
    1dd0:	90 e0       	ldi	r25, 0x00	; 0
    1dd2:	60 e0       	ldi	r22, 0x00	; 0
    1dd4:	70 e0       	ldi	r23, 0x00	; 0
    1dd6:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		velocity(190,177);
    1dda:	8e eb       	ldi	r24, 0xBE	; 190
    1ddc:	61 eb       	ldi	r22, 0xB1	; 177
    1dde:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		backward_mm(30);
    1de2:	8e e1       	ldi	r24, 0x1E	; 30
    1de4:	90 e0       	ldi	r25, 0x00	; 0
    1de6:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		fw_follow_black_line();
    1dea:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		left_degrees(90,0);
    1dee:	8a e5       	ldi	r24, 0x5A	; 90
    1df0:	90 e0       	ldi	r25, 0x00	; 0
    1df2:	60 e0       	ldi	r22, 0x00	; 0
    1df4:	70 e0       	ldi	r23, 0x00	; 0
    1df6:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		backward_mm(20);
    1dfa:	84 e1       	ldi	r24, 0x14	; 20
    1dfc:	90 e0       	ldi	r25, 0x00	; 0
    1dfe:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		drop_weight();
    1e02:	0e 94 82 0a 	call	0x1504	; 0x1504 <drop_weight>
		backward_mm(25);
    1e06:	89 e1       	ldi	r24, 0x19	; 25
    1e08:	90 e0       	ldi	r25, 0x00	; 0
    1e0a:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		
		//starts again to put second weight block 
		left_degrees(88,0);
    1e0e:	88 e5       	ldi	r24, 0x58	; 88
    1e10:	90 e0       	ldi	r25, 0x00	; 0
    1e12:	60 e0       	ldi	r22, 0x00	; 0
    1e14:	70 e0       	ldi	r23, 0x00	; 0
    1e16:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    1e1a:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		pick_block(82);
    1e1e:	82 e5       	ldi	r24, 0x52	; 82
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		right_degrees(180,0);
    1e26:	84 eb       	ldi	r24, 0xB4	; 180
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	60 e0       	ldi	r22, 0x00	; 0
    1e2c:	70 e0       	ldi	r23, 0x00	; 0
    1e2e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    1e32:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		left_degrees(88,0);
    1e36:	88 e5       	ldi	r24, 0x58	; 88
    1e38:	90 e0       	ldi	r25, 0x00	; 0
    1e3a:	60 e0       	ldi	r22, 0x00	; 0
    1e3c:	70 e0       	ldi	r23, 0x00	; 0
    1e3e:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		backward_mm(20);
    1e42:	84 e1       	ldi	r24, 0x14	; 20
    1e44:	90 e0       	ldi	r25, 0x00	; 0
    1e46:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		drop_weight();
    1e4a:	0e 94 82 0a 	call	0x1504	; 0x1504 <drop_weight>
		backward_mm(20);
    1e4e:	84 e1       	ldi	r24, 0x14	; 20
    1e50:	90 e0       	ldi	r25, 0x00	; 0
    1e52:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		
		//goes to node(0,1)
		right_degrees(88,0);
    1e56:	88 e5       	ldi	r24, 0x58	; 88
    1e58:	90 e0       	ldi	r25, 0x00	; 0
    1e5a:	60 e0       	ldi	r22, 0x00	; 0
    1e5c:	70 e0       	ldi	r23, 0x00	; 0
    1e5e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    1e62:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		left_degrees(67,1);
    1e66:	83 e4       	ldi	r24, 0x43	; 67
    1e68:	90 e0       	ldi	r25, 0x00	; 0
    1e6a:	61 e0       	ldi	r22, 0x01	; 1
    1e6c:	70 e0       	ldi	r23, 0x00	; 0
    1e6e:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();	
    1e72:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    1e76:	bc c0       	rjmp	.+376    	; 0x1ff0 <balanceBridge+0x2fa>
	}
	//when flag value is 2 will take two weight blocks from node(1,0) and will balance the bridge in CA
	if (flag==2)
    1e78:	82 30       	cpi	r24, 0x02	; 2
    1e7a:	91 05       	cpc	r25, r1
    1e7c:	c9 f5       	brne	.+114    	; 0x1ef0 <balanceBridge+0x1fa>
	{
		servo_1(150);
    1e7e:	86 e9       	ldi	r24, 0x96	; 150
    1e80:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
    1e84:	8f ef       	ldi	r24, 0xFF	; 255
    1e86:	9f ef       	ldi	r25, 0xFF	; 255
    1e88:	ac e2       	ldi	r26, 0x2C	; 44
    1e8a:	81 50       	subi	r24, 0x01	; 1
    1e8c:	90 40       	sbci	r25, 0x00	; 0
    1e8e:	a0 40       	sbci	r26, 0x00	; 0
    1e90:	e1 f7       	brne	.-8      	; 0x1e8a <balanceBridge+0x194>
    1e92:	00 c0       	rjmp	.+0      	; 0x1e94 <balanceBridge+0x19e>
    1e94:	00 00       	nop
		_delay_ms(1000);
		node0_0(3);
    1e96:	83 e0       	ldi	r24, 0x03	; 3
    1e98:	90 e0       	ldi	r25, 0x00	; 0
    1e9a:	0e 94 b6 0a 	call	0x156c	; 0x156c <node0_0>
		fw_follow_black_line();
    1e9e:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		fw_follow_black_line();
    1ea2:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		node_m1_0(0);				//drops first weight in weight container
    1ea6:	80 e0       	ldi	r24, 0x00	; 0
    1ea8:	90 e0       	ldi	r25, 0x00	; 0
    1eaa:	0e 94 c9 0b 	call	0x1792	; 0x1792 <node_m1_0>
		 
		fw_follow_black_line();
    1eae:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		left_degrees(100,0);
    1eb2:	84 e6       	ldi	r24, 0x64	; 100
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	60 e0       	ldi	r22, 0x00	; 0
    1eb8:	70 e0       	ldi	r23, 0x00	; 0
    1eba:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		pick_block(82);
    1ebe:	82 e5       	ldi	r24, 0x52	; 82
    1ec0:	90 e0       	ldi	r25, 0x00	; 0
    1ec2:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		right_degrees(88,0);
    1ec6:	88 e5       	ldi	r24, 0x58	; 88
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	60 e0       	ldi	r22, 0x00	; 0
    1ecc:	70 e0       	ldi	r23, 0x00	; 0
    1ece:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    1ed2:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		fw_follow_black_line();
    1ed6:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		node_m1_0(0);				//drops second weight in weight container 
    1eda:	80 e0       	ldi	r24, 0x00	; 0
    1edc:	90 e0       	ldi	r25, 0x00	; 0
    1ede:	0e 94 c9 0b 	call	0x1792	; 0x1792 <node_m1_0>
		
		//Goes to initial position i.e. node(0,0)
		right_degrees(88,1);
    1ee2:	88 e5       	ldi	r24, 0x58	; 88
    1ee4:	90 e0       	ldi	r25, 0x00	; 0
    1ee6:	61 e0       	ldi	r22, 0x01	; 1
    1ee8:	70 e0       	ldi	r23, 0x00	; 0
    1eea:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
    1eee:	b9 c0       	rjmp	.+370    	; 0x2062 <balanceBridge+0x36c>
	}
	//when flag value is 3 will take two weight blocks from node(-1,1) and will balance the bridge in IA and again it will carry one weight from IA to the
	// CA since we have one less weight block in CA and it will put that in weight container of CA
	if (flag==3)
    1ef0:	c3 30       	cpi	r28, 0x03	; 3
    1ef2:	d1 05       	cpc	r29, r1
    1ef4:	09 f0       	breq	.+2      	; 0x1ef8 <balanceBridge+0x202>
    1ef6:	7c c0       	rjmp	.+248    	; 0x1ff0 <balanceBridge+0x2fa>
	{
		servo_1(150);
    1ef8:	86 e9       	ldi	r24, 0x96	; 150
    1efa:	0e 94 01 09 	call	0x1202	; 0x1202 <servo_1>
		servo_2(120);
    1efe:	88 e7       	ldi	r24, 0x78	; 120
    1f00:	0e 94 1a 09 	call	0x1234	; 0x1234 <servo_2>
    1f04:	8f ef       	ldi	r24, 0xFF	; 255
    1f06:	9f ef       	ldi	r25, 0xFF	; 255
    1f08:	ac e2       	ldi	r26, 0x2C	; 44
    1f0a:	81 50       	subi	r24, 0x01	; 1
    1f0c:	90 40       	sbci	r25, 0x00	; 0
    1f0e:	a0 40       	sbci	r26, 0x00	; 0
    1f10:	e1 f7       	brne	.-8      	; 0x1f0a <balanceBridge+0x214>
    1f12:	00 c0       	rjmp	.+0      	; 0x1f14 <balanceBridge+0x21e>
    1f14:	00 00       	nop
		_delay_ms(1000);
		right_degrees(88,0);
    1f16:	88 e5       	ldi	r24, 0x58	; 88
    1f18:	90 e0       	ldi	r25, 0x00	; 0
    1f1a:	60 e0       	ldi	r22, 0x00	; 0
    1f1c:	70 e0       	ldi	r23, 0x00	; 0
    1f1e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		backward_mm(30);
    1f22:	8e e1       	ldi	r24, 0x1E	; 30
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		fw_follow_black_line();
    1f2a:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		backward_mm(20);
    1f2e:	84 e1       	ldi	r24, 0x14	; 20
    1f30:	90 e0       	ldi	r25, 0x00	; 0
    1f32:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		pick_block(90);
    1f36:	8a e5       	ldi	r24, 0x5A	; 90
    1f38:	90 e0       	ldi	r25, 0x00	; 0
    1f3a:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		forward_mm(30);
    1f3e:	8e e1       	ldi	r24, 0x1E	; 30
    1f40:	90 e0       	ldi	r25, 0x00	; 0
    1f42:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		left_degrees(180,0);
    1f46:	84 eb       	ldi	r24, 0xB4	; 180
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	60 e0       	ldi	r22, 0x00	; 0
    1f4c:	70 e0       	ldi	r23, 0x00	; 0
    1f4e:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    1f52:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		fw_follow_black_line();
    1f56:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		right_degrees(88,0);
    1f5a:	88 e5       	ldi	r24, 0x58	; 88
    1f5c:	90 e0       	ldi	r25, 0x00	; 0
    1f5e:	60 e0       	ldi	r22, 0x00	; 0
    1f60:	70 e0       	ldi	r23, 0x00	; 0
    1f62:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		drop_weight();				//drops first weight in weight block container
    1f66:	0e 94 82 0a 	call	0x1504	; 0x1504 <drop_weight>
		
		//returns back to pick second weight block
		right_degrees(88,0);
    1f6a:	88 e5       	ldi	r24, 0x58	; 88
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	60 e0       	ldi	r22, 0x00	; 0
    1f70:	70 e0       	ldi	r23, 0x00	; 0
    1f72:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    1f76:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		fw_follow_black_line();
    1f7a:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		pick_block(82);
    1f7e:	82 e5       	ldi	r24, 0x52	; 82
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		left_degrees(176,0);
    1f86:	80 eb       	ldi	r24, 0xB0	; 176
    1f88:	90 e0       	ldi	r25, 0x00	; 0
    1f8a:	60 e0       	ldi	r22, 0x00	; 0
    1f8c:	70 e0       	ldi	r23, 0x00	; 0
    1f8e:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    1f92:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		fw_follow_black_line();
    1f96:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		right_degrees(88,0);
    1f9a:	88 e5       	ldi	r24, 0x58	; 88
    1f9c:	90 e0       	ldi	r25, 0x00	; 0
    1f9e:	60 e0       	ldi	r22, 0x00	; 0
    1fa0:	70 e0       	ldi	r23, 0x00	; 0
    1fa2:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		drop_weight();				//drops second weight in weight block container
    1fa6:	0e 94 82 0a 	call	0x1504	; 0x1504 <drop_weight>
		right_degrees(88,0);
    1faa:	88 e5       	ldi	r24, 0x58	; 88
    1fac:	90 e0       	ldi	r25, 0x00	; 0
    1fae:	60 e0       	ldi	r22, 0x00	; 0
    1fb0:	70 e0       	ldi	r23, 0x00	; 0
    1fb2:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    1fb6:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		fw_follow_black_line();
    1fba:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		left_degrees(88,0);
    1fbe:	88 e5       	ldi	r24, 0x58	; 88
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	60 e0       	ldi	r22, 0x00	; 0
    1fc4:	70 e0       	ldi	r23, 0x00	; 0
    1fc6:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		pick_block(90);				//pick one more weight block and carries that weight block to CA
    1fca:	8a e5       	ldi	r24, 0x5A	; 90
    1fcc:	90 e0       	ldi	r25, 0x00	; 0
    1fce:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		left_degrees(88,0);
    1fd2:	88 e5       	ldi	r24, 0x58	; 88
    1fd4:	90 e0       	ldi	r25, 0x00	; 0
    1fd6:	60 e0       	ldi	r22, 0x00	; 0
    1fd8:	70 e0       	ldi	r23, 0x00	; 0
    1fda:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    1fde:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		right_degrees(88,0);
    1fe2:	88 e5       	ldi	r24, 0x58	; 88
    1fe4:	90 e0       	ldi	r25, 0x00	; 0
    1fe6:	60 e0       	ldi	r22, 0x00	; 0
    1fe8:	70 e0       	ldi	r23, 0x00	; 0
    1fea:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
    1fee:	39 c0       	rjmp	.+114    	; 0x2062 <balanceBridge+0x36c>
	}
	//when flag value is 4 will take two weight blocks from node(-2,0) and will balance the bridge in CA
	if (flag==4)
    1ff0:	c4 30       	cpi	r28, 0x04	; 4
    1ff2:	d1 05       	cpc	r29, r1
    1ff4:	b1 f5       	brne	.+108    	; 0x2062 <balanceBridge+0x36c>
	{
		right_degrees(88,0);
    1ff6:	88 e5       	ldi	r24, 0x58	; 88
    1ff8:	90 e0       	ldi	r25, 0x00	; 0
    1ffa:	60 e0       	ldi	r22, 0x00	; 0
    1ffc:	70 e0       	ldi	r23, 0x00	; 0
    1ffe:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		fw_follow_black_line();
    2002:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		velocity(180,180);
    2006:	84 eb       	ldi	r24, 0xB4	; 180
    2008:	64 eb       	ldi	r22, 0xB4	; 180
    200a:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
		right_degrees(90,0);
    200e:	8a e5       	ldi	r24, 0x5A	; 90
    2010:	90 e0       	ldi	r25, 0x00	; 0
    2012:	60 e0       	ldi	r22, 0x00	; 0
    2014:	70 e0       	ldi	r23, 0x00	; 0
    2016:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
		backward_mm(20);
    201a:	84 e1       	ldi	r24, 0x14	; 20
    201c:	90 e0       	ldi	r25, 0x00	; 0
    201e:	0e 94 ca 05 	call	0xb94	; 0xb94 <backward_mm>
		drop_weight();			//puts the carried weight block from IA to CA
    2022:	0e 94 82 0a 	call	0x1504	; 0x1504 <drop_weight>
		left_degrees(88,0);
    2026:	88 e5       	ldi	r24, 0x58	; 88
    2028:	90 e0       	ldi	r25, 0x00	; 0
    202a:	60 e0       	ldi	r22, 0x00	; 0
    202c:	70 e0       	ldi	r23, 0x00	; 0
    202e:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    2032:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		pick_block(82);			//picks another weight block from node(-2,1) and drops that in weight container in CA
    2036:	82 e5       	ldi	r24, 0x52	; 82
    2038:	90 e0       	ldi	r25, 0x00	; 0
    203a:	0e 94 a1 09 	call	0x1342	; 0x1342 <pick_block>
		left_degrees(176,0);
    203e:	80 eb       	ldi	r24, 0xB0	; 176
    2040:	90 e0       	ldi	r25, 0x00	; 0
    2042:	60 e0       	ldi	r22, 0x00	; 0
    2044:	70 e0       	ldi	r23, 0x00	; 0
    2046:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
		fw_follow_black_line();
    204a:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
		node_m1_0(1);
    204e:	81 e0       	ldi	r24, 0x01	; 1
    2050:	90 e0       	ldi	r25, 0x00	; 0
    2052:	0e 94 c9 0b 	call	0x1792	; 0x1792 <node_m1_0>
		right_degrees(88,0);		//reaches to the starting position that node(0,0) from where it will take the third waste block
    2056:	88 e5       	ldi	r24, 0x58	; 88
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	60 e0       	ldi	r22, 0x00	; 0
    205c:	70 e0       	ldi	r23, 0x00	; 0
    205e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <right_degrees>
	}
    2062:	df 91       	pop	r29
    2064:	cf 91       	pop	r28
    2066:	08 95       	ret

00002068 <detect_third_waste>:
* Output :return values
* Logic: It is used to detect the third block as it is mutually exclusive
* Example Call: detect_third_waste();
*/
int detect_third_waste(){
	if (sortedFlag[0] == 1 && sortedFlag[1] == 2) {
    2068:	80 91 26 02 	lds	r24, 0x0226
    206c:	90 91 27 02 	lds	r25, 0x0227
    2070:	81 30       	cpi	r24, 0x01	; 1
    2072:	91 05       	cpc	r25, r1
    2074:	71 f4       	brne	.+28     	; 0x2092 <detect_third_waste+0x2a>
    2076:	80 91 28 02 	lds	r24, 0x0228
    207a:	90 91 29 02 	lds	r25, 0x0229
    207e:	82 30       	cpi	r24, 0x02	; 2
    2080:	91 05       	cpc	r25, r1
    2082:	c1 f4       	brne	.+48     	; 0x20b4 <detect_third_waste+0x4c>
		sortedFlag[2] = 3;
    2084:	83 e0       	ldi	r24, 0x03	; 3
    2086:	90 e0       	ldi	r25, 0x00	; 0
    2088:	90 93 2b 02 	sts	0x022B, r25
    208c:	80 93 2a 02 	sts	0x022A, r24
		return 3;
    2090:	08 95       	ret
	} else if (sortedFlag[0] == 2 && sortedFlag[1] == 3) {
    2092:	82 30       	cpi	r24, 0x02	; 2
    2094:	91 05       	cpc	r25, r1
    2096:	71 f4       	brne	.+28     	; 0x20b4 <detect_third_waste+0x4c>
    2098:	80 91 28 02 	lds	r24, 0x0228
    209c:	90 91 29 02 	lds	r25, 0x0229
    20a0:	83 30       	cpi	r24, 0x03	; 3
    20a2:	91 05       	cpc	r25, r1
    20a4:	39 f4       	brne	.+14     	; 0x20b4 <detect_third_waste+0x4c>
		sortedFlag[2] = 1;
    20a6:	81 e0       	ldi	r24, 0x01	; 1
    20a8:	90 e0       	ldi	r25, 0x00	; 0
    20aa:	90 93 2b 02 	sts	0x022B, r25
    20ae:	80 93 2a 02 	sts	0x022A, r24
		return 1;
    20b2:	08 95       	ret
	} else {
		sortedFlag[2] = 2;
    20b4:	82 e0       	ldi	r24, 0x02	; 2
    20b6:	90 e0       	ldi	r25, 0x00	; 0
    20b8:	90 93 2b 02 	sts	0x022B, r25
    20bc:	80 93 2a 02 	sts	0x022A, r24
		return 2;
	}			
}
    20c0:	08 95       	ret

000020c2 <main>:

/*Main function in which all the function are called from different header files*/
int main(void)
{
	//Initializes all the pins from different header files and working of each function is explained in their respective header file
	init_devices_color();
    20c2:	0e 94 1a 01 	call	0x234	; 0x234 <init_devices_color>
	lcd_set_4bit();
    20c6:	0e 94 67 07 	call	0xece	; 0xece <lcd_set_4bit>
	color_sensor_scaling();
    20ca:	0e 94 2a 01 	call	0x254	; 0x254 <color_sensor_scaling>
	init_devices();
    20ce:	0e 94 36 05 	call	0xa6c	; 0xa6c <init_devices>
	lcd_port_config ();
    20d2:	0e 94 ac 00 	call	0x158	; 0x158 <lcd_port_config>
	lcd_init();
    20d6:	0e 94 ef 07 	call	0xfde	; 0xfde <lcd_init>
	buzzer_pin_config();
    20da:	0e 94 cb 08 	call	0x1196	; 0x1196 <buzzer_pin_config>
	motion_pin_config ();
    20de:	0e 94 a4 02 	call	0x548	; 0x548 <motion_pin_config>
	timer5_init();
    20e2:	0e 94 b5 02 	call	0x56a	; 0x56a <timer5_init>
	adc_pin_config ();
    20e6:	0e 94 b3 00 	call	0x166	; 0x166 <adc_pin_config>
	adc_init();
    20ea:	0e 94 ba 00 	call	0x174	; 0x174 <adc_init>
	servo1_pin_config();
    20ee:	0e 94 ce 08 	call	0x119c	; 0x119c <servo1_pin_config>
	servo2_pin_config();
    20f2:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <servo2_pin_config>
	timer1_init();
    20f6:	0e 94 de 08 	call	0x11bc	; 0x11bc <timer1_init>
    20fa:	8f ef       	ldi	r24, 0xFF	; 255
    20fc:	9f eb       	ldi	r25, 0xBF	; 191
    20fe:	a6 e0       	ldi	r26, 0x06	; 6
    2100:	81 50       	subi	r24, 0x01	; 1
    2102:	90 40       	sbci	r25, 0x00	; 0
    2104:	a0 40       	sbci	r26, 0x00	; 0
    2106:	e1 f7       	brne	.-8      	; 0x2100 <main+0x3e>
    2108:	00 c0       	rjmp	.+0      	; 0x210a <main+0x48>
    210a:	00 00       	nop
	
	_delay_ms(150);
	/************************FIRST RUN*******************************/
	node0_0(4);		//initial 180 degrees turn
    210c:	84 e0       	ldi	r24, 0x04	; 4
    210e:	90 e0       	ldi	r25, 0x00	; 0
    2110:	0e 94 b6 0a 	call	0x156c	; 0x156c <node0_0>
	node0_0(1);
    2114:	81 e0       	ldi	r24, 0x01	; 1
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	0e 94 b6 0a 	call	0x156c	; 0x156c <node0_0>
	node_m1_0(2);		//goes forward
    211c:	82 e0       	ldi	r24, 0x02	; 2
    211e:	90 e0       	ldi	r25, 0x00	; 0
    2120:	0e 94 c9 0b 	call	0x1792	; 0x1792 <node_m1_0>
	node_m2_0(1);	
    2124:	81 e0       	ldi	r24, 0x01	; 1
    2126:	90 e0       	ldi	r25, 0x00	; 0
    2128:	0e 94 2b 0c 	call	0x1856	; 0x1856 <node_m2_0>
	node_m1_0(3);
    212c:	83 e0       	ldi	r24, 0x03	; 3
    212e:	90 e0       	ldi	r25, 0x00	; 0
    2130:	0e 94 c9 0b 	call	0x1792	; 0x1792 <node_m1_0>
	forward_mm(30);		
    2134:	8e e1       	ldi	r24, 0x1E	; 30
    2136:	90 e0       	ldi	r25, 0x00	; 0
    2138:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
	node0_0(0);
    213c:	80 e0       	ldi	r24, 0x00	; 0
    213e:	90 e0       	ldi	r25, 0x00	; 0
    2140:	0e 94 b6 0a 	call	0x156c	; 0x156c <node0_0>
	velocity(180,180);
    2144:	84 eb       	ldi	r24, 0xB4	; 180
    2146:	64 eb       	ldi	r22, 0xB4	; 180
    2148:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <velocity>
	node_0_1(0,1);
    214c:	80 e0       	ldi	r24, 0x00	; 0
    214e:	90 e0       	ldi	r25, 0x00	; 0
    2150:	61 e0       	ldi	r22, 0x01	; 1
    2152:	70 e0       	ldi	r23, 0x00	; 0
    2154:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
	node_0_1(1,0);
    2158:	81 e0       	ldi	r24, 0x01	; 1
    215a:	90 e0       	ldi	r25, 0x00	; 0
    215c:	60 e0       	ldi	r22, 0x00	; 0
    215e:	70 e0       	ldi	r23, 0x00	; 0
    2160:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
	node_m1_1(0,1);			//comes back
    2164:	80 e0       	ldi	r24, 0x00	; 0
    2166:	90 e0       	ldi	r25, 0x00	; 0
    2168:	61 e0       	ldi	r22, 0x01	; 1
    216a:	70 e0       	ldi	r23, 0x00	; 0
    216c:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <node_m1_1>
	fw_follow_black_line();
    2170:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
	
	/************************SECOND RUN**********************************/
	
		
		node0_0(5);
    2174:	85 e0       	ldi	r24, 0x05	; 5
    2176:	90 e0       	ldi	r25, 0x00	; 0
    2178:	0e 94 b6 0a 	call	0x156c	; 0x156c <node0_0>
		node_m1_0(2);		//goes forward
    217c:	82 e0       	ldi	r24, 0x02	; 2
    217e:	90 e0       	ldi	r25, 0x00	; 0
    2180:	0e 94 c9 0b 	call	0x1792	; 0x1792 <node_m1_0>
		node_m2_0(1);
    2184:	81 e0       	ldi	r24, 0x01	; 1
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	0e 94 2b 0c 	call	0x1856	; 0x1856 <node_m2_0>
		node_m1_0(3);
    218c:	83 e0       	ldi	r24, 0x03	; 3
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	0e 94 c9 0b 	call	0x1792	; 0x1792 <node_m1_0>
		forward_mm(30);	
    2194:	8e e1       	ldi	r24, 0x1E	; 30
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	0e 94 bf 05 	call	0xb7e	; 0xb7e <forward_mm>
		node0_0(0);
    219c:	80 e0       	ldi	r24, 0x00	; 0
    219e:	90 e0       	ldi	r25, 0x00	; 0
    21a0:	0e 94 b6 0a 	call	0x156c	; 0x156c <node0_0>
	
		if(sortedFlag[1] == b_flag){
    21a4:	80 91 28 02 	lds	r24, 0x0228
    21a8:	90 91 29 02 	lds	r25, 0x0229
    21ac:	20 91 20 02 	lds	r18, 0x0220
    21b0:	30 91 21 02 	lds	r19, 0x0221
    21b4:	82 17       	cp	r24, r18
    21b6:	93 07       	cpc	r25, r19
    21b8:	e1 f4       	brne	.+56     	; 0x21f2 <main+0x130>
			buzzer_on();
    21ba:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    21be:	8f ef       	ldi	r24, 0xFF	; 255
    21c0:	9f ef       	ldi	r25, 0xFF	; 255
    21c2:	a8 e0       	ldi	r26, 0x08	; 8
    21c4:	81 50       	subi	r24, 0x01	; 1
    21c6:	90 40       	sbci	r25, 0x00	; 0
    21c8:	a0 40       	sbci	r26, 0x00	; 0
    21ca:	e1 f7       	brne	.-8      	; 0x21c4 <main+0x102>
    21cc:	00 c0       	rjmp	.+0      	; 0x21ce <main+0x10c>
    21ce:	00 00       	nop
			_delay_ms(200);
			buzzer_off();
    21d0:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			node_0_1(0,0);
    21d4:	80 e0       	ldi	r24, 0x00	; 0
    21d6:	90 e0       	ldi	r25, 0x00	; 0
    21d8:	60 e0       	ldi	r22, 0x00	; 0
    21da:	70 e0       	ldi	r23, 0x00	; 0
    21dc:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
			left_degrees(176,1);
    21e0:	80 eb       	ldi	r24, 0xB0	; 176
    21e2:	90 e0       	ldi	r25, 0x00	; 0
    21e4:	61 e0       	ldi	r22, 0x01	; 1
    21e6:	70 e0       	ldi	r23, 0x00	; 0
    21e8:	0e 94 9b 06 	call	0xd36	; 0xd36 <left_degrees>
			fw_follow_black_line();	
    21ec:	0e 94 13 05 	call	0xa26	; 0xa26 <fw_follow_black_line>
    21f0:	2e c0       	rjmp	.+92     	; 0x224e <__stack+0x4f>
		}
		else if(sortedFlag[1] == c_flag){
    21f2:	20 91 1e 02 	lds	r18, 0x021E
    21f6:	30 91 1f 02 	lds	r19, 0x021F
    21fa:	82 17       	cp	r24, r18
    21fc:	93 07       	cpc	r25, r19
    21fe:	99 f4       	brne	.+38     	; 0x2226 <__stack+0x27>
			node_0_1(1,0);
    2200:	81 e0       	ldi	r24, 0x01	; 1
    2202:	90 e0       	ldi	r25, 0x00	; 0
    2204:	60 e0       	ldi	r22, 0x00	; 0
    2206:	70 e0       	ldi	r23, 0x00	; 0
    2208:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
			node_m1_1(0,0);
    220c:	80 e0       	ldi	r24, 0x00	; 0
    220e:	90 e0       	ldi	r25, 0x00	; 0
    2210:	60 e0       	ldi	r22, 0x00	; 0
    2212:	70 e0       	ldi	r23, 0x00	; 0
    2214:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <node_m1_1>
			node_0_1(2,0);
    2218:	82 e0       	ldi	r24, 0x02	; 2
    221a:	90 e0       	ldi	r25, 0x00	; 0
    221c:	60 e0       	ldi	r22, 0x00	; 0
    221e:	70 e0       	ldi	r23, 0x00	; 0
    2220:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
    2224:	14 c0       	rjmp	.+40     	; 0x224e <__stack+0x4f>
		}
		else{
			node_0_1(2,0);
    2226:	82 e0       	ldi	r24, 0x02	; 2
    2228:	90 e0       	ldi	r25, 0x00	; 0
    222a:	60 e0       	ldi	r22, 0x00	; 0
    222c:	70 e0       	ldi	r23, 0x00	; 0
    222e:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
			node_1_1(2);
    2232:	82 e0       	ldi	r24, 0x02	; 2
    2234:	90 e0       	ldi	r25, 0x00	; 0
    2236:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <node_1_1>
			node_2_1(0);
    223a:	80 e0       	ldi	r24, 0x00	; 0
    223c:	90 e0       	ldi	r25, 0x00	; 0
    223e:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <node_2_1>
			node_0_1(2,0);			//comes back
    2242:	82 e0       	ldi	r24, 0x02	; 2
    2244:	90 e0       	ldi	r25, 0x00	; 0
    2246:	60 e0       	ldi	r22, 0x00	; 0
    2248:	70 e0       	ldi	r23, 0x00	; 0
    224a:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
		}
	
	/************************THIRD RUN**********************************************/
	node0_0(6);
    224e:	86 e0       	ldi	r24, 0x06	; 6
    2250:	90 e0       	ldi	r25, 0x00	; 0
    2252:	0e 94 b6 0a 	call	0x156c	; 0x156c <node0_0>
	
		if(detect_third_waste() == b_flag){
    2256:	0e 94 34 10 	call	0x2068	; 0x2068 <detect_third_waste>
    225a:	20 91 20 02 	lds	r18, 0x0220
    225e:	30 91 21 02 	lds	r19, 0x0221
    2262:	82 17       	cp	r24, r18
    2264:	93 07       	cpc	r25, r19
    2266:	a1 f4       	brne	.+40     	; 0x2290 <__stack+0x91>
			buzzer_on();
    2268:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    226c:	8f ef       	ldi	r24, 0xFF	; 255
    226e:	9f ef       	ldi	r25, 0xFF	; 255
    2270:	a8 e0       	ldi	r26, 0x08	; 8
    2272:	81 50       	subi	r24, 0x01	; 1
    2274:	90 40       	sbci	r25, 0x00	; 0
    2276:	a0 40       	sbci	r26, 0x00	; 0
    2278:	e1 f7       	brne	.-8      	; 0x2272 <__stack+0x73>
    227a:	00 c0       	rjmp	.+0      	; 0x227c <__stack+0x7d>
    227c:	00 00       	nop
			_delay_ms(200);
			buzzer_off();
    227e:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			node_0_1(0,0);
    2282:	80 e0       	ldi	r24, 0x00	; 0
    2284:	90 e0       	ldi	r25, 0x00	; 0
    2286:	60 e0       	ldi	r22, 0x00	; 0
    2288:	70 e0       	ldi	r23, 0x00	; 0
    228a:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
    228e:	24 c0       	rjmp	.+72     	; 0x22d8 <__stack+0xd9>
		}
		else if(detect_third_waste() == c_flag){
    2290:	0e 94 34 10 	call	0x2068	; 0x2068 <detect_third_waste>
    2294:	20 91 1e 02 	lds	r18, 0x021E
    2298:	30 91 1f 02 	lds	r19, 0x021F
    229c:	82 17       	cp	r24, r18
    229e:	93 07       	cpc	r25, r19
    22a0:	69 f4       	brne	.+26     	; 0x22bc <__stack+0xbd>
			node_0_1(1,0);
    22a2:	81 e0       	ldi	r24, 0x01	; 1
    22a4:	90 e0       	ldi	r25, 0x00	; 0
    22a6:	60 e0       	ldi	r22, 0x00	; 0
    22a8:	70 e0       	ldi	r23, 0x00	; 0
    22aa:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
			node_m1_1(0,0);
    22ae:	80 e0       	ldi	r24, 0x00	; 0
    22b0:	90 e0       	ldi	r25, 0x00	; 0
    22b2:	60 e0       	ldi	r22, 0x00	; 0
    22b4:	70 e0       	ldi	r23, 0x00	; 0
    22b6:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <node_m1_1>
    22ba:	0e c0       	rjmp	.+28     	; 0x22d8 <__stack+0xd9>
		}
		else{
			node_0_1(2,0);
    22bc:	82 e0       	ldi	r24, 0x02	; 2
    22be:	90 e0       	ldi	r25, 0x00	; 0
    22c0:	60 e0       	ldi	r22, 0x00	; 0
    22c2:	70 e0       	ldi	r23, 0x00	; 0
    22c4:	0e 94 a8 0c 	call	0x1950	; 0x1950 <node_0_1>
			node_1_1(2);
    22c8:	82 e0       	ldi	r24, 0x02	; 2
    22ca:	90 e0       	ldi	r25, 0x00	; 0
    22cc:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <node_1_1>
			node_2_1(0);			//comes back
    22d0:	80 e0       	ldi	r24, 0x00	; 0
    22d2:	90 e0       	ldi	r25, 0x00	; 0
    22d4:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <node_2_1>
		}
		
	/**********************************************************************************/
	//Continuous Buzzer Beep........	
	buzzer_on();
    22d8:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    22dc:	8f ef       	ldi	r24, 0xFF	; 255
    22de:	9f ef       	ldi	r25, 0xFF	; 255
    22e0:	a0 ee       	ldi	r26, 0xE0	; 224
    22e2:	b0 e0       	ldi	r27, 0x00	; 0
    22e4:	81 50       	subi	r24, 0x01	; 1
    22e6:	90 40       	sbci	r25, 0x00	; 0
    22e8:	a0 40       	sbci	r26, 0x00	; 0
    22ea:	b0 40       	sbci	r27, 0x00	; 0
    22ec:	d9 f7       	brne	.-10     	; 0x22e4 <__stack+0xe5>
    22ee:	00 c0       	rjmp	.+0      	; 0x22f0 <__stack+0xf1>
    22f0:	00 00       	nop
	_delay_ms(6000);
	buzzer_off();
    22f2:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
	return 0;
    22f6:	80 e0       	ldi	r24, 0x00	; 0
    22f8:	90 e0       	ldi	r25, 0x00	; 0
    22fa:	08 95       	ret

000022fc <__subsf3>:
    22fc:	50 58       	subi	r21, 0x80	; 128

000022fe <__addsf3>:
    22fe:	bb 27       	eor	r27, r27
    2300:	aa 27       	eor	r26, r26
    2302:	0e d0       	rcall	.+28     	; 0x2320 <__addsf3x>
    2304:	75 c1       	rjmp	.+746    	; 0x25f0 <__fp_round>
    2306:	66 d1       	rcall	.+716    	; 0x25d4 <__fp_pscA>
    2308:	30 f0       	brcs	.+12     	; 0x2316 <__addsf3+0x18>
    230a:	6b d1       	rcall	.+726    	; 0x25e2 <__fp_pscB>
    230c:	20 f0       	brcs	.+8      	; 0x2316 <__addsf3+0x18>
    230e:	31 f4       	brne	.+12     	; 0x231c <__addsf3+0x1e>
    2310:	9f 3f       	cpi	r25, 0xFF	; 255
    2312:	11 f4       	brne	.+4      	; 0x2318 <__addsf3+0x1a>
    2314:	1e f4       	brtc	.+6      	; 0x231c <__addsf3+0x1e>
    2316:	5b c1       	rjmp	.+694    	; 0x25ce <__fp_nan>
    2318:	0e f4       	brtc	.+2      	; 0x231c <__addsf3+0x1e>
    231a:	e0 95       	com	r30
    231c:	e7 fb       	bst	r30, 7
    231e:	51 c1       	rjmp	.+674    	; 0x25c2 <__fp_inf>

00002320 <__addsf3x>:
    2320:	e9 2f       	mov	r30, r25
    2322:	77 d1       	rcall	.+750    	; 0x2612 <__fp_split3>
    2324:	80 f3       	brcs	.-32     	; 0x2306 <__addsf3+0x8>
    2326:	ba 17       	cp	r27, r26
    2328:	62 07       	cpc	r22, r18
    232a:	73 07       	cpc	r23, r19
    232c:	84 07       	cpc	r24, r20
    232e:	95 07       	cpc	r25, r21
    2330:	18 f0       	brcs	.+6      	; 0x2338 <__addsf3x+0x18>
    2332:	71 f4       	brne	.+28     	; 0x2350 <__addsf3x+0x30>
    2334:	9e f5       	brtc	.+102    	; 0x239c <__addsf3x+0x7c>
    2336:	8f c1       	rjmp	.+798    	; 0x2656 <__fp_zero>
    2338:	0e f4       	brtc	.+2      	; 0x233c <__addsf3x+0x1c>
    233a:	e0 95       	com	r30
    233c:	0b 2e       	mov	r0, r27
    233e:	ba 2f       	mov	r27, r26
    2340:	a0 2d       	mov	r26, r0
    2342:	0b 01       	movw	r0, r22
    2344:	b9 01       	movw	r22, r18
    2346:	90 01       	movw	r18, r0
    2348:	0c 01       	movw	r0, r24
    234a:	ca 01       	movw	r24, r20
    234c:	a0 01       	movw	r20, r0
    234e:	11 24       	eor	r1, r1
    2350:	ff 27       	eor	r31, r31
    2352:	59 1b       	sub	r21, r25
    2354:	99 f0       	breq	.+38     	; 0x237c <__addsf3x+0x5c>
    2356:	59 3f       	cpi	r21, 0xF9	; 249
    2358:	50 f4       	brcc	.+20     	; 0x236e <__addsf3x+0x4e>
    235a:	50 3e       	cpi	r21, 0xE0	; 224
    235c:	68 f1       	brcs	.+90     	; 0x23b8 <__addsf3x+0x98>
    235e:	1a 16       	cp	r1, r26
    2360:	f0 40       	sbci	r31, 0x00	; 0
    2362:	a2 2f       	mov	r26, r18
    2364:	23 2f       	mov	r18, r19
    2366:	34 2f       	mov	r19, r20
    2368:	44 27       	eor	r20, r20
    236a:	58 5f       	subi	r21, 0xF8	; 248
    236c:	f3 cf       	rjmp	.-26     	; 0x2354 <__addsf3x+0x34>
    236e:	46 95       	lsr	r20
    2370:	37 95       	ror	r19
    2372:	27 95       	ror	r18
    2374:	a7 95       	ror	r26
    2376:	f0 40       	sbci	r31, 0x00	; 0
    2378:	53 95       	inc	r21
    237a:	c9 f7       	brne	.-14     	; 0x236e <__addsf3x+0x4e>
    237c:	7e f4       	brtc	.+30     	; 0x239c <__addsf3x+0x7c>
    237e:	1f 16       	cp	r1, r31
    2380:	ba 0b       	sbc	r27, r26
    2382:	62 0b       	sbc	r22, r18
    2384:	73 0b       	sbc	r23, r19
    2386:	84 0b       	sbc	r24, r20
    2388:	ba f0       	brmi	.+46     	; 0x23b8 <__addsf3x+0x98>
    238a:	91 50       	subi	r25, 0x01	; 1
    238c:	a1 f0       	breq	.+40     	; 0x23b6 <__addsf3x+0x96>
    238e:	ff 0f       	add	r31, r31
    2390:	bb 1f       	adc	r27, r27
    2392:	66 1f       	adc	r22, r22
    2394:	77 1f       	adc	r23, r23
    2396:	88 1f       	adc	r24, r24
    2398:	c2 f7       	brpl	.-16     	; 0x238a <__addsf3x+0x6a>
    239a:	0e c0       	rjmp	.+28     	; 0x23b8 <__addsf3x+0x98>
    239c:	ba 0f       	add	r27, r26
    239e:	62 1f       	adc	r22, r18
    23a0:	73 1f       	adc	r23, r19
    23a2:	84 1f       	adc	r24, r20
    23a4:	48 f4       	brcc	.+18     	; 0x23b8 <__addsf3x+0x98>
    23a6:	87 95       	ror	r24
    23a8:	77 95       	ror	r23
    23aa:	67 95       	ror	r22
    23ac:	b7 95       	ror	r27
    23ae:	f7 95       	ror	r31
    23b0:	9e 3f       	cpi	r25, 0xFE	; 254
    23b2:	08 f0       	brcs	.+2      	; 0x23b6 <__addsf3x+0x96>
    23b4:	b3 cf       	rjmp	.-154    	; 0x231c <__addsf3+0x1e>
    23b6:	93 95       	inc	r25
    23b8:	88 0f       	add	r24, r24
    23ba:	08 f0       	brcs	.+2      	; 0x23be <__addsf3x+0x9e>
    23bc:	99 27       	eor	r25, r25
    23be:	ee 0f       	add	r30, r30
    23c0:	97 95       	ror	r25
    23c2:	87 95       	ror	r24
    23c4:	08 95       	ret

000023c6 <__cmpsf2>:
    23c6:	d9 d0       	rcall	.+434    	; 0x257a <__fp_cmp>
    23c8:	08 f4       	brcc	.+2      	; 0x23cc <__cmpsf2+0x6>
    23ca:	81 e0       	ldi	r24, 0x01	; 1
    23cc:	08 95       	ret

000023ce <__divsf3>:
    23ce:	0c d0       	rcall	.+24     	; 0x23e8 <__divsf3x>
    23d0:	0f c1       	rjmp	.+542    	; 0x25f0 <__fp_round>
    23d2:	07 d1       	rcall	.+526    	; 0x25e2 <__fp_pscB>
    23d4:	40 f0       	brcs	.+16     	; 0x23e6 <__divsf3+0x18>
    23d6:	fe d0       	rcall	.+508    	; 0x25d4 <__fp_pscA>
    23d8:	30 f0       	brcs	.+12     	; 0x23e6 <__divsf3+0x18>
    23da:	21 f4       	brne	.+8      	; 0x23e4 <__divsf3+0x16>
    23dc:	5f 3f       	cpi	r21, 0xFF	; 255
    23de:	19 f0       	breq	.+6      	; 0x23e6 <__divsf3+0x18>
    23e0:	f0 c0       	rjmp	.+480    	; 0x25c2 <__fp_inf>
    23e2:	51 11       	cpse	r21, r1
    23e4:	39 c1       	rjmp	.+626    	; 0x2658 <__fp_szero>
    23e6:	f3 c0       	rjmp	.+486    	; 0x25ce <__fp_nan>

000023e8 <__divsf3x>:
    23e8:	14 d1       	rcall	.+552    	; 0x2612 <__fp_split3>
    23ea:	98 f3       	brcs	.-26     	; 0x23d2 <__divsf3+0x4>

000023ec <__divsf3_pse>:
    23ec:	99 23       	and	r25, r25
    23ee:	c9 f3       	breq	.-14     	; 0x23e2 <__divsf3+0x14>
    23f0:	55 23       	and	r21, r21
    23f2:	b1 f3       	breq	.-20     	; 0x23e0 <__divsf3+0x12>
    23f4:	95 1b       	sub	r25, r21
    23f6:	55 0b       	sbc	r21, r21
    23f8:	bb 27       	eor	r27, r27
    23fa:	aa 27       	eor	r26, r26
    23fc:	62 17       	cp	r22, r18
    23fe:	73 07       	cpc	r23, r19
    2400:	84 07       	cpc	r24, r20
    2402:	38 f0       	brcs	.+14     	; 0x2412 <__divsf3_pse+0x26>
    2404:	9f 5f       	subi	r25, 0xFF	; 255
    2406:	5f 4f       	sbci	r21, 0xFF	; 255
    2408:	22 0f       	add	r18, r18
    240a:	33 1f       	adc	r19, r19
    240c:	44 1f       	adc	r20, r20
    240e:	aa 1f       	adc	r26, r26
    2410:	a9 f3       	breq	.-22     	; 0x23fc <__divsf3_pse+0x10>
    2412:	33 d0       	rcall	.+102    	; 0x247a <__divsf3_pse+0x8e>
    2414:	0e 2e       	mov	r0, r30
    2416:	3a f0       	brmi	.+14     	; 0x2426 <__divsf3_pse+0x3a>
    2418:	e0 e8       	ldi	r30, 0x80	; 128
    241a:	30 d0       	rcall	.+96     	; 0x247c <__divsf3_pse+0x90>
    241c:	91 50       	subi	r25, 0x01	; 1
    241e:	50 40       	sbci	r21, 0x00	; 0
    2420:	e6 95       	lsr	r30
    2422:	00 1c       	adc	r0, r0
    2424:	ca f7       	brpl	.-14     	; 0x2418 <__divsf3_pse+0x2c>
    2426:	29 d0       	rcall	.+82     	; 0x247a <__divsf3_pse+0x8e>
    2428:	fe 2f       	mov	r31, r30
    242a:	27 d0       	rcall	.+78     	; 0x247a <__divsf3_pse+0x8e>
    242c:	66 0f       	add	r22, r22
    242e:	77 1f       	adc	r23, r23
    2430:	88 1f       	adc	r24, r24
    2432:	bb 1f       	adc	r27, r27
    2434:	26 17       	cp	r18, r22
    2436:	37 07       	cpc	r19, r23
    2438:	48 07       	cpc	r20, r24
    243a:	ab 07       	cpc	r26, r27
    243c:	b0 e8       	ldi	r27, 0x80	; 128
    243e:	09 f0       	breq	.+2      	; 0x2442 <__divsf3_pse+0x56>
    2440:	bb 0b       	sbc	r27, r27
    2442:	80 2d       	mov	r24, r0
    2444:	bf 01       	movw	r22, r30
    2446:	ff 27       	eor	r31, r31
    2448:	93 58       	subi	r25, 0x83	; 131
    244a:	5f 4f       	sbci	r21, 0xFF	; 255
    244c:	2a f0       	brmi	.+10     	; 0x2458 <__divsf3_pse+0x6c>
    244e:	9e 3f       	cpi	r25, 0xFE	; 254
    2450:	51 05       	cpc	r21, r1
    2452:	68 f0       	brcs	.+26     	; 0x246e <__divsf3_pse+0x82>
    2454:	b6 c0       	rjmp	.+364    	; 0x25c2 <__fp_inf>
    2456:	00 c1       	rjmp	.+512    	; 0x2658 <__fp_szero>
    2458:	5f 3f       	cpi	r21, 0xFF	; 255
    245a:	ec f3       	brlt	.-6      	; 0x2456 <__divsf3_pse+0x6a>
    245c:	98 3e       	cpi	r25, 0xE8	; 232
    245e:	dc f3       	brlt	.-10     	; 0x2456 <__divsf3_pse+0x6a>
    2460:	86 95       	lsr	r24
    2462:	77 95       	ror	r23
    2464:	67 95       	ror	r22
    2466:	b7 95       	ror	r27
    2468:	f7 95       	ror	r31
    246a:	9f 5f       	subi	r25, 0xFF	; 255
    246c:	c9 f7       	brne	.-14     	; 0x2460 <__divsf3_pse+0x74>
    246e:	88 0f       	add	r24, r24
    2470:	91 1d       	adc	r25, r1
    2472:	96 95       	lsr	r25
    2474:	87 95       	ror	r24
    2476:	97 f9       	bld	r25, 7
    2478:	08 95       	ret
    247a:	e1 e0       	ldi	r30, 0x01	; 1
    247c:	66 0f       	add	r22, r22
    247e:	77 1f       	adc	r23, r23
    2480:	88 1f       	adc	r24, r24
    2482:	bb 1f       	adc	r27, r27
    2484:	62 17       	cp	r22, r18
    2486:	73 07       	cpc	r23, r19
    2488:	84 07       	cpc	r24, r20
    248a:	ba 07       	cpc	r27, r26
    248c:	20 f0       	brcs	.+8      	; 0x2496 <__divsf3_pse+0xaa>
    248e:	62 1b       	sub	r22, r18
    2490:	73 0b       	sbc	r23, r19
    2492:	84 0b       	sbc	r24, r20
    2494:	ba 0b       	sbc	r27, r26
    2496:	ee 1f       	adc	r30, r30
    2498:	88 f7       	brcc	.-30     	; 0x247c <__divsf3_pse+0x90>
    249a:	e0 95       	com	r30
    249c:	08 95       	ret

0000249e <__fixsfsi>:
    249e:	04 d0       	rcall	.+8      	; 0x24a8 <__fixunssfsi>
    24a0:	68 94       	set
    24a2:	b1 11       	cpse	r27, r1
    24a4:	d9 c0       	rjmp	.+434    	; 0x2658 <__fp_szero>
    24a6:	08 95       	ret

000024a8 <__fixunssfsi>:
    24a8:	bc d0       	rcall	.+376    	; 0x2622 <__fp_splitA>
    24aa:	88 f0       	brcs	.+34     	; 0x24ce <__fixunssfsi+0x26>
    24ac:	9f 57       	subi	r25, 0x7F	; 127
    24ae:	90 f0       	brcs	.+36     	; 0x24d4 <__fixunssfsi+0x2c>
    24b0:	b9 2f       	mov	r27, r25
    24b2:	99 27       	eor	r25, r25
    24b4:	b7 51       	subi	r27, 0x17	; 23
    24b6:	a0 f0       	brcs	.+40     	; 0x24e0 <__fixunssfsi+0x38>
    24b8:	d1 f0       	breq	.+52     	; 0x24ee <__fixunssfsi+0x46>
    24ba:	66 0f       	add	r22, r22
    24bc:	77 1f       	adc	r23, r23
    24be:	88 1f       	adc	r24, r24
    24c0:	99 1f       	adc	r25, r25
    24c2:	1a f0       	brmi	.+6      	; 0x24ca <__fixunssfsi+0x22>
    24c4:	ba 95       	dec	r27
    24c6:	c9 f7       	brne	.-14     	; 0x24ba <__fixunssfsi+0x12>
    24c8:	12 c0       	rjmp	.+36     	; 0x24ee <__fixunssfsi+0x46>
    24ca:	b1 30       	cpi	r27, 0x01	; 1
    24cc:	81 f0       	breq	.+32     	; 0x24ee <__fixunssfsi+0x46>
    24ce:	c3 d0       	rcall	.+390    	; 0x2656 <__fp_zero>
    24d0:	b1 e0       	ldi	r27, 0x01	; 1
    24d2:	08 95       	ret
    24d4:	c0 c0       	rjmp	.+384    	; 0x2656 <__fp_zero>
    24d6:	67 2f       	mov	r22, r23
    24d8:	78 2f       	mov	r23, r24
    24da:	88 27       	eor	r24, r24
    24dc:	b8 5f       	subi	r27, 0xF8	; 248
    24de:	39 f0       	breq	.+14     	; 0x24ee <__fixunssfsi+0x46>
    24e0:	b9 3f       	cpi	r27, 0xF9	; 249
    24e2:	cc f3       	brlt	.-14     	; 0x24d6 <__fixunssfsi+0x2e>
    24e4:	86 95       	lsr	r24
    24e6:	77 95       	ror	r23
    24e8:	67 95       	ror	r22
    24ea:	b3 95       	inc	r27
    24ec:	d9 f7       	brne	.-10     	; 0x24e4 <__fixunssfsi+0x3c>
    24ee:	3e f4       	brtc	.+14     	; 0x24fe <__fixunssfsi+0x56>
    24f0:	90 95       	com	r25
    24f2:	80 95       	com	r24
    24f4:	70 95       	com	r23
    24f6:	61 95       	neg	r22
    24f8:	7f 4f       	sbci	r23, 0xFF	; 255
    24fa:	8f 4f       	sbci	r24, 0xFF	; 255
    24fc:	9f 4f       	sbci	r25, 0xFF	; 255
    24fe:	08 95       	ret

00002500 <__floatunsisf>:
    2500:	e8 94       	clt
    2502:	09 c0       	rjmp	.+18     	; 0x2516 <__floatsisf+0x12>

00002504 <__floatsisf>:
    2504:	97 fb       	bst	r25, 7
    2506:	3e f4       	brtc	.+14     	; 0x2516 <__floatsisf+0x12>
    2508:	90 95       	com	r25
    250a:	80 95       	com	r24
    250c:	70 95       	com	r23
    250e:	61 95       	neg	r22
    2510:	7f 4f       	sbci	r23, 0xFF	; 255
    2512:	8f 4f       	sbci	r24, 0xFF	; 255
    2514:	9f 4f       	sbci	r25, 0xFF	; 255
    2516:	99 23       	and	r25, r25
    2518:	a9 f0       	breq	.+42     	; 0x2544 <__floatsisf+0x40>
    251a:	f9 2f       	mov	r31, r25
    251c:	96 e9       	ldi	r25, 0x96	; 150
    251e:	bb 27       	eor	r27, r27
    2520:	93 95       	inc	r25
    2522:	f6 95       	lsr	r31
    2524:	87 95       	ror	r24
    2526:	77 95       	ror	r23
    2528:	67 95       	ror	r22
    252a:	b7 95       	ror	r27
    252c:	f1 11       	cpse	r31, r1
    252e:	f8 cf       	rjmp	.-16     	; 0x2520 <__floatsisf+0x1c>
    2530:	fa f4       	brpl	.+62     	; 0x2570 <__floatsisf+0x6c>
    2532:	bb 0f       	add	r27, r27
    2534:	11 f4       	brne	.+4      	; 0x253a <__floatsisf+0x36>
    2536:	60 ff       	sbrs	r22, 0
    2538:	1b c0       	rjmp	.+54     	; 0x2570 <__floatsisf+0x6c>
    253a:	6f 5f       	subi	r22, 0xFF	; 255
    253c:	7f 4f       	sbci	r23, 0xFF	; 255
    253e:	8f 4f       	sbci	r24, 0xFF	; 255
    2540:	9f 4f       	sbci	r25, 0xFF	; 255
    2542:	16 c0       	rjmp	.+44     	; 0x2570 <__floatsisf+0x6c>
    2544:	88 23       	and	r24, r24
    2546:	11 f0       	breq	.+4      	; 0x254c <__floatsisf+0x48>
    2548:	96 e9       	ldi	r25, 0x96	; 150
    254a:	11 c0       	rjmp	.+34     	; 0x256e <__floatsisf+0x6a>
    254c:	77 23       	and	r23, r23
    254e:	21 f0       	breq	.+8      	; 0x2558 <__floatsisf+0x54>
    2550:	9e e8       	ldi	r25, 0x8E	; 142
    2552:	87 2f       	mov	r24, r23
    2554:	76 2f       	mov	r23, r22
    2556:	05 c0       	rjmp	.+10     	; 0x2562 <__floatsisf+0x5e>
    2558:	66 23       	and	r22, r22
    255a:	71 f0       	breq	.+28     	; 0x2578 <__floatsisf+0x74>
    255c:	96 e8       	ldi	r25, 0x86	; 134
    255e:	86 2f       	mov	r24, r22
    2560:	70 e0       	ldi	r23, 0x00	; 0
    2562:	60 e0       	ldi	r22, 0x00	; 0
    2564:	2a f0       	brmi	.+10     	; 0x2570 <__floatsisf+0x6c>
    2566:	9a 95       	dec	r25
    2568:	66 0f       	add	r22, r22
    256a:	77 1f       	adc	r23, r23
    256c:	88 1f       	adc	r24, r24
    256e:	da f7       	brpl	.-10     	; 0x2566 <__floatsisf+0x62>
    2570:	88 0f       	add	r24, r24
    2572:	96 95       	lsr	r25
    2574:	87 95       	ror	r24
    2576:	97 f9       	bld	r25, 7
    2578:	08 95       	ret

0000257a <__fp_cmp>:
    257a:	99 0f       	add	r25, r25
    257c:	00 08       	sbc	r0, r0
    257e:	55 0f       	add	r21, r21
    2580:	aa 0b       	sbc	r26, r26
    2582:	e0 e8       	ldi	r30, 0x80	; 128
    2584:	fe ef       	ldi	r31, 0xFE	; 254
    2586:	16 16       	cp	r1, r22
    2588:	17 06       	cpc	r1, r23
    258a:	e8 07       	cpc	r30, r24
    258c:	f9 07       	cpc	r31, r25
    258e:	c0 f0       	brcs	.+48     	; 0x25c0 <__fp_cmp+0x46>
    2590:	12 16       	cp	r1, r18
    2592:	13 06       	cpc	r1, r19
    2594:	e4 07       	cpc	r30, r20
    2596:	f5 07       	cpc	r31, r21
    2598:	98 f0       	brcs	.+38     	; 0x25c0 <__fp_cmp+0x46>
    259a:	62 1b       	sub	r22, r18
    259c:	73 0b       	sbc	r23, r19
    259e:	84 0b       	sbc	r24, r20
    25a0:	95 0b       	sbc	r25, r21
    25a2:	39 f4       	brne	.+14     	; 0x25b2 <__fp_cmp+0x38>
    25a4:	0a 26       	eor	r0, r26
    25a6:	61 f0       	breq	.+24     	; 0x25c0 <__fp_cmp+0x46>
    25a8:	23 2b       	or	r18, r19
    25aa:	24 2b       	or	r18, r20
    25ac:	25 2b       	or	r18, r21
    25ae:	21 f4       	brne	.+8      	; 0x25b8 <__fp_cmp+0x3e>
    25b0:	08 95       	ret
    25b2:	0a 26       	eor	r0, r26
    25b4:	09 f4       	brne	.+2      	; 0x25b8 <__fp_cmp+0x3e>
    25b6:	a1 40       	sbci	r26, 0x01	; 1
    25b8:	a6 95       	lsr	r26
    25ba:	8f ef       	ldi	r24, 0xFF	; 255
    25bc:	81 1d       	adc	r24, r1
    25be:	81 1d       	adc	r24, r1
    25c0:	08 95       	ret

000025c2 <__fp_inf>:
    25c2:	97 f9       	bld	r25, 7
    25c4:	9f 67       	ori	r25, 0x7F	; 127
    25c6:	80 e8       	ldi	r24, 0x80	; 128
    25c8:	70 e0       	ldi	r23, 0x00	; 0
    25ca:	60 e0       	ldi	r22, 0x00	; 0
    25cc:	08 95       	ret

000025ce <__fp_nan>:
    25ce:	9f ef       	ldi	r25, 0xFF	; 255
    25d0:	80 ec       	ldi	r24, 0xC0	; 192
    25d2:	08 95       	ret

000025d4 <__fp_pscA>:
    25d4:	00 24       	eor	r0, r0
    25d6:	0a 94       	dec	r0
    25d8:	16 16       	cp	r1, r22
    25da:	17 06       	cpc	r1, r23
    25dc:	18 06       	cpc	r1, r24
    25de:	09 06       	cpc	r0, r25
    25e0:	08 95       	ret

000025e2 <__fp_pscB>:
    25e2:	00 24       	eor	r0, r0
    25e4:	0a 94       	dec	r0
    25e6:	12 16       	cp	r1, r18
    25e8:	13 06       	cpc	r1, r19
    25ea:	14 06       	cpc	r1, r20
    25ec:	05 06       	cpc	r0, r21
    25ee:	08 95       	ret

000025f0 <__fp_round>:
    25f0:	09 2e       	mov	r0, r25
    25f2:	03 94       	inc	r0
    25f4:	00 0c       	add	r0, r0
    25f6:	11 f4       	brne	.+4      	; 0x25fc <__fp_round+0xc>
    25f8:	88 23       	and	r24, r24
    25fa:	52 f0       	brmi	.+20     	; 0x2610 <__fp_round+0x20>
    25fc:	bb 0f       	add	r27, r27
    25fe:	40 f4       	brcc	.+16     	; 0x2610 <__fp_round+0x20>
    2600:	bf 2b       	or	r27, r31
    2602:	11 f4       	brne	.+4      	; 0x2608 <__fp_round+0x18>
    2604:	60 ff       	sbrs	r22, 0
    2606:	04 c0       	rjmp	.+8      	; 0x2610 <__fp_round+0x20>
    2608:	6f 5f       	subi	r22, 0xFF	; 255
    260a:	7f 4f       	sbci	r23, 0xFF	; 255
    260c:	8f 4f       	sbci	r24, 0xFF	; 255
    260e:	9f 4f       	sbci	r25, 0xFF	; 255
    2610:	08 95       	ret

00002612 <__fp_split3>:
    2612:	57 fd       	sbrc	r21, 7
    2614:	90 58       	subi	r25, 0x80	; 128
    2616:	44 0f       	add	r20, r20
    2618:	55 1f       	adc	r21, r21
    261a:	59 f0       	breq	.+22     	; 0x2632 <__fp_splitA+0x10>
    261c:	5f 3f       	cpi	r21, 0xFF	; 255
    261e:	71 f0       	breq	.+28     	; 0x263c <__fp_splitA+0x1a>
    2620:	47 95       	ror	r20

00002622 <__fp_splitA>:
    2622:	88 0f       	add	r24, r24
    2624:	97 fb       	bst	r25, 7
    2626:	99 1f       	adc	r25, r25
    2628:	61 f0       	breq	.+24     	; 0x2642 <__fp_splitA+0x20>
    262a:	9f 3f       	cpi	r25, 0xFF	; 255
    262c:	79 f0       	breq	.+30     	; 0x264c <__fp_splitA+0x2a>
    262e:	87 95       	ror	r24
    2630:	08 95       	ret
    2632:	12 16       	cp	r1, r18
    2634:	13 06       	cpc	r1, r19
    2636:	14 06       	cpc	r1, r20
    2638:	55 1f       	adc	r21, r21
    263a:	f2 cf       	rjmp	.-28     	; 0x2620 <__fp_split3+0xe>
    263c:	46 95       	lsr	r20
    263e:	f1 df       	rcall	.-30     	; 0x2622 <__fp_splitA>
    2640:	08 c0       	rjmp	.+16     	; 0x2652 <__fp_splitA+0x30>
    2642:	16 16       	cp	r1, r22
    2644:	17 06       	cpc	r1, r23
    2646:	18 06       	cpc	r1, r24
    2648:	99 1f       	adc	r25, r25
    264a:	f1 cf       	rjmp	.-30     	; 0x262e <__fp_splitA+0xc>
    264c:	86 95       	lsr	r24
    264e:	71 05       	cpc	r23, r1
    2650:	61 05       	cpc	r22, r1
    2652:	08 94       	sec
    2654:	08 95       	ret

00002656 <__fp_zero>:
    2656:	e8 94       	clt

00002658 <__fp_szero>:
    2658:	bb 27       	eor	r27, r27
    265a:	66 27       	eor	r22, r22
    265c:	77 27       	eor	r23, r23
    265e:	cb 01       	movw	r24, r22
    2660:	97 f9       	bld	r25, 7
    2662:	08 95       	ret

00002664 <__mulsf3>:
    2664:	0b d0       	rcall	.+22     	; 0x267c <__mulsf3x>
    2666:	c4 cf       	rjmp	.-120    	; 0x25f0 <__fp_round>
    2668:	b5 df       	rcall	.-150    	; 0x25d4 <__fp_pscA>
    266a:	28 f0       	brcs	.+10     	; 0x2676 <__mulsf3+0x12>
    266c:	ba df       	rcall	.-140    	; 0x25e2 <__fp_pscB>
    266e:	18 f0       	brcs	.+6      	; 0x2676 <__mulsf3+0x12>
    2670:	95 23       	and	r25, r21
    2672:	09 f0       	breq	.+2      	; 0x2676 <__mulsf3+0x12>
    2674:	a6 cf       	rjmp	.-180    	; 0x25c2 <__fp_inf>
    2676:	ab cf       	rjmp	.-170    	; 0x25ce <__fp_nan>
    2678:	11 24       	eor	r1, r1
    267a:	ee cf       	rjmp	.-36     	; 0x2658 <__fp_szero>

0000267c <__mulsf3x>:
    267c:	ca df       	rcall	.-108    	; 0x2612 <__fp_split3>
    267e:	a0 f3       	brcs	.-24     	; 0x2668 <__mulsf3+0x4>

00002680 <__mulsf3_pse>:
    2680:	95 9f       	mul	r25, r21
    2682:	d1 f3       	breq	.-12     	; 0x2678 <__mulsf3+0x14>
    2684:	95 0f       	add	r25, r21
    2686:	50 e0       	ldi	r21, 0x00	; 0
    2688:	55 1f       	adc	r21, r21
    268a:	62 9f       	mul	r22, r18
    268c:	f0 01       	movw	r30, r0
    268e:	72 9f       	mul	r23, r18
    2690:	bb 27       	eor	r27, r27
    2692:	f0 0d       	add	r31, r0
    2694:	b1 1d       	adc	r27, r1
    2696:	63 9f       	mul	r22, r19
    2698:	aa 27       	eor	r26, r26
    269a:	f0 0d       	add	r31, r0
    269c:	b1 1d       	adc	r27, r1
    269e:	aa 1f       	adc	r26, r26
    26a0:	64 9f       	mul	r22, r20
    26a2:	66 27       	eor	r22, r22
    26a4:	b0 0d       	add	r27, r0
    26a6:	a1 1d       	adc	r26, r1
    26a8:	66 1f       	adc	r22, r22
    26aa:	82 9f       	mul	r24, r18
    26ac:	22 27       	eor	r18, r18
    26ae:	b0 0d       	add	r27, r0
    26b0:	a1 1d       	adc	r26, r1
    26b2:	62 1f       	adc	r22, r18
    26b4:	73 9f       	mul	r23, r19
    26b6:	b0 0d       	add	r27, r0
    26b8:	a1 1d       	adc	r26, r1
    26ba:	62 1f       	adc	r22, r18
    26bc:	83 9f       	mul	r24, r19
    26be:	a0 0d       	add	r26, r0
    26c0:	61 1d       	adc	r22, r1
    26c2:	22 1f       	adc	r18, r18
    26c4:	74 9f       	mul	r23, r20
    26c6:	33 27       	eor	r19, r19
    26c8:	a0 0d       	add	r26, r0
    26ca:	61 1d       	adc	r22, r1
    26cc:	23 1f       	adc	r18, r19
    26ce:	84 9f       	mul	r24, r20
    26d0:	60 0d       	add	r22, r0
    26d2:	21 1d       	adc	r18, r1
    26d4:	82 2f       	mov	r24, r18
    26d6:	76 2f       	mov	r23, r22
    26d8:	6a 2f       	mov	r22, r26
    26da:	11 24       	eor	r1, r1
    26dc:	9f 57       	subi	r25, 0x7F	; 127
    26de:	50 40       	sbci	r21, 0x00	; 0
    26e0:	8a f0       	brmi	.+34     	; 0x2704 <__mulsf3_pse+0x84>
    26e2:	e1 f0       	breq	.+56     	; 0x271c <__mulsf3_pse+0x9c>
    26e4:	88 23       	and	r24, r24
    26e6:	4a f0       	brmi	.+18     	; 0x26fa <__mulsf3_pse+0x7a>
    26e8:	ee 0f       	add	r30, r30
    26ea:	ff 1f       	adc	r31, r31
    26ec:	bb 1f       	adc	r27, r27
    26ee:	66 1f       	adc	r22, r22
    26f0:	77 1f       	adc	r23, r23
    26f2:	88 1f       	adc	r24, r24
    26f4:	91 50       	subi	r25, 0x01	; 1
    26f6:	50 40       	sbci	r21, 0x00	; 0
    26f8:	a9 f7       	brne	.-22     	; 0x26e4 <__mulsf3_pse+0x64>
    26fa:	9e 3f       	cpi	r25, 0xFE	; 254
    26fc:	51 05       	cpc	r21, r1
    26fe:	70 f0       	brcs	.+28     	; 0x271c <__mulsf3_pse+0x9c>
    2700:	60 cf       	rjmp	.-320    	; 0x25c2 <__fp_inf>
    2702:	aa cf       	rjmp	.-172    	; 0x2658 <__fp_szero>
    2704:	5f 3f       	cpi	r21, 0xFF	; 255
    2706:	ec f3       	brlt	.-6      	; 0x2702 <__mulsf3_pse+0x82>
    2708:	98 3e       	cpi	r25, 0xE8	; 232
    270a:	dc f3       	brlt	.-10     	; 0x2702 <__mulsf3_pse+0x82>
    270c:	86 95       	lsr	r24
    270e:	77 95       	ror	r23
    2710:	67 95       	ror	r22
    2712:	b7 95       	ror	r27
    2714:	f7 95       	ror	r31
    2716:	e7 95       	ror	r30
    2718:	9f 5f       	subi	r25, 0xFF	; 255
    271a:	c1 f7       	brne	.-16     	; 0x270c <__mulsf3_pse+0x8c>
    271c:	fe 2b       	or	r31, r30
    271e:	88 0f       	add	r24, r24
    2720:	91 1d       	adc	r25, r1
    2722:	96 95       	lsr	r25
    2724:	87 95       	ror	r24
    2726:	97 f9       	bld	r25, 7
    2728:	08 95       	ret

0000272a <__udivmodhi4>:
    272a:	aa 1b       	sub	r26, r26
    272c:	bb 1b       	sub	r27, r27
    272e:	51 e1       	ldi	r21, 0x11	; 17
    2730:	07 c0       	rjmp	.+14     	; 0x2740 <__udivmodhi4_ep>

00002732 <__udivmodhi4_loop>:
    2732:	aa 1f       	adc	r26, r26
    2734:	bb 1f       	adc	r27, r27
    2736:	a6 17       	cp	r26, r22
    2738:	b7 07       	cpc	r27, r23
    273a:	10 f0       	brcs	.+4      	; 0x2740 <__udivmodhi4_ep>
    273c:	a6 1b       	sub	r26, r22
    273e:	b7 0b       	sbc	r27, r23

00002740 <__udivmodhi4_ep>:
    2740:	88 1f       	adc	r24, r24
    2742:	99 1f       	adc	r25, r25
    2744:	5a 95       	dec	r21
    2746:	a9 f7       	brne	.-22     	; 0x2732 <__udivmodhi4_loop>
    2748:	80 95       	com	r24
    274a:	90 95       	com	r25
    274c:	bc 01       	movw	r22, r24
    274e:	cd 01       	movw	r24, r26
    2750:	08 95       	ret

00002752 <_exit>:
    2752:	f8 94       	cli

00002754 <__stop_program>:
    2754:	ff cf       	rjmp	.-2      	; 0x2754 <__stop_program>
